<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快速排序</title>
    <url>/2023/03/25/Arithmetic_Quick_Sort/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为:任取待排序 元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有 元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所 有元素都排列在相应位置上为止。<br><strong>将区间按照基准值划分为左右两半部分的常见方式有:</strong></p>
<p><strong>1.挖坑法 2.左右指针法 3.前后指针法</strong></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>O(N*log 	N)</strong></p>
<p><a href="https://cloudimge.com/image/nzVKR"><img src="https://c.1ovv.com/2023/03/25/nzVKR.md.jpeg" alt="nzVKR.md.jpeg" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>不稳定排序</p>
<h1 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h1><p><a href="https://cloudimge.com/image/nzdjd"><img src="https://c.1ovv.com/2023/03/25/nzdjd.md.png" alt="nzdjd.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<p>先讲左端或右端的值设定为key,key右边的值比key大，左边的值比key小，也就是说end–的行动方式为&gt;a[key]，同理左边的行动方式为&lt;a[key]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挖坑法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将中间值置换到begin位置，解决有序最坏的情况</span></span><br><span class="line">	<span class="type">int</span> mid = <span class="built_in">GetMidIndex</span>(a, left, right);</span><br><span class="line">	<span class="built_in">swap</span>(a[left], a[mid]);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = left, end = right;</span><br><span class="line">	<span class="type">int</span> key = a[begin];</span><br><span class="line">	<span class="type">int</span> pivot = begin;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//右边找小，放到左边</span></span><br><span class="line">		<span class="keyword">while</span> (a[end] &gt;= key &amp;&amp; begin &lt; end)<span class="comment">//判断范围加全，避免在--的过程中，end&lt;begin 注意是&gt;=  ＝一定要加上不然容易死循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//小的放到左边坑位，自己形成新的坑位</span></span><br><span class="line">		a[pivot] = a[end];</span><br><span class="line">		pivot = end;</span><br><span class="line">		<span class="comment">//左边找大，放到右边</span></span><br><span class="line">		<span class="keyword">while</span> (a[begin] &lt;= key &amp;&amp; begin &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">		a[pivot] = a[begin];</span><br><span class="line">		pivot = begin;</span><br><span class="line">	&#125;</span><br><span class="line">	pivot = begin;</span><br><span class="line">	a[begin] = key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前后指针法"><a href="#前后指针法" class="headerlink" title="前后指针法"></a>前后指针法</h1><p><a href="https://cloudimge.com/image/nzfL4"><img src="https://c.1ovv.com/2023/03/25/nzfL4.md.png" alt="nzfL4.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针法 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> prev = left, cur = left + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> keyi = left;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur] &lt;= a[keyi] &amp;&amp; ++prev != cur)<span class="comment">//注意是前置++    ++prev != cur 防止自己与自己交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev++;</span><br><span class="line">			<span class="built_in">Swap</span>(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">		&#125;</span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Swap</span>(&amp;a[keyi], &amp;a[prev]);</span><br><span class="line">	keyi = prev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> keyi;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="左右指针法"><a href="#左右指针法" class="headerlink" title="左右指针法"></a>左右指针法</h1><p>同挖洞法，左边找大，右边找小，然后交换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挖坑法类似，，左右指针法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将中间值置换到begin位置，解决有序最坏的情况</span></span><br><span class="line">	<span class="type">int</span> mid = <span class="built_in">GetMidIndex</span>(a, left, right);</span><br><span class="line">	<span class="built_in">swap</span>(a[left], a[mid]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = left, end = right;</span><br><span class="line">	<span class="type">int</span> keyi = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end &amp;&amp; a[end] &gt;= a[keyi])</span><br><span class="line">		&#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end &amp;&amp; a[begin] &lt;= a[keyi])</span><br><span class="line">		&#123;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(a[begin], a[end]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(a[keyi], a[begin]);</span><br><span class="line">	keyi = begin;</span><br><span class="line">	<span class="keyword">return</span> keyi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三数取中"><a href="#三数取中" class="headerlink" title="三数取中"></a>三数取中</h1><p><a href="https://cloudimge.com/image/nzrvW"><img src="https://c.1ovv.com/2023/03/25/nzrvW.md.png" alt="nzrvW.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<p>若不采用三数取中，时间复杂度为n^2；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMidIndex</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (a[left] &gt; a[mid])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &gt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[left] &gt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//a[left] &lt; a[mid]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[left] &lt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="上述方法的主函数"><a href="#上述方法的主函数" class="headerlink" title="上述方法的主函数"></a>上述方法的主函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> KeyIndex = <span class="built_in">PartSort3</span>(a, left, right);</span><br><span class="line">	<span class="comment">//[left,right]</span></span><br><span class="line">	<span class="comment">//[left,KeyIndex-1]KeyIndex[KeyIndex+1,right]</span></span><br><span class="line">	<span class="comment">////左右子区间有序了，那么整个数组有序， 怎么有序 分而自治</span></span><br><span class="line">	<span class="comment">//QuickSort(a, left, KeyIndex - 1);</span></span><br><span class="line">	<span class="comment">//QuickSort(a, KeyIndex + 1, right);</span></span><br><span class="line">	<span class="comment">//又因为一直左右区间分，最后每个区间排 浪费数据量太小，没必要再调用快空间，增加消耗   故采用小区间优化(效果不明显，几毫秒的作用）</span></span><br><span class="line">		<span class="built_in">QuickSort</span>(a, left, KeyIndex - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">QuickSort</span>(a, KeyIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="快排非递归"><a href="#快排非递归" class="headerlink" title="快排非递归"></a>快排非递归</h1><p>通过模拟栈来划分左右区间，一定是右边界先入栈，然后左边界，对每个区间都是如此，这样取得时候就是先取左边界</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/快排非递归</span><br><span class="line"><span class="comment">//快速排序非递归</span></span><br><span class="line"><span class="comment">//递归的缺陷？： ，递归深度太深，栈空间不够，容易造成栈溢出</span></span><br><span class="line"><span class="comment">//递归改非递归：1、(一般简单递归）直接改循环2、借助数据结构栈模拟递归过程（复杂递归)/////需要栈///队列也可以模拟</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="comment">//栈先进后出，故先进右区间点，再进左区间点</span></span><br><span class="line">    st.<span class="built_in">push</span>(n<span class="number">-1</span>);</span><br><span class="line">	st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> right = st.<span class="built_in">top</span>();</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> KeyIndex = <span class="built_in">PartSort1</span>(a, left, right);</span><br><span class="line">		<span class="comment">//[left,KeyIndex] KeyIndex[KeyIndex+1,right]</span></span><br><span class="line">		<span class="comment">//先判断左区间，再判断右区间，所以先入右区间，再入左区间</span></span><br><span class="line">		<span class="keyword">if</span> (KeyIndex + <span class="number">1</span> &lt; right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//先入右区间点，再入左区间点</span></span><br><span class="line">			st.<span class="built_in">push</span>(right);</span><br><span class="line">			st.<span class="built_in">push</span>(KeyIndex+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (left &lt; KeyIndex - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.<span class="built_in">push</span>(KeyIndex - <span class="number">1</span>);</span><br><span class="line">			st.<span class="built_in">push</span>(left);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="优化方案-采取左右指针"><a href="#优化方案-采取左右指针" class="headerlink" title="优化方案-采取左右指针"></a>优化方案-采取左右指针</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-deque</title>
    <url>/2023/03/24/STL-deque/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>逻辑上是连续的存储空间，实际上是由很多块定量的块空间，通过中控器连接起来</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>随机访问迭代器</p>
<h1 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>deque <code>&lt;T&gt;</code> deqT;&#x2F;&#x2F;默认构造形式</p>
<p>deque(beg, end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>deque(n, elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p>deque(const deque &amp;deq);&#x2F;&#x2F;拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(arr,arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">10</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<p>deque&amp;operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</p>
<p>swap(deq);&#x2F;&#x2F; 将deq与本身的元素互换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    d1.<span class="built_in">assign</span>(arr,arr+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">print</span>(d1);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">swap</span>(d1);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    <span class="built_in">print</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>deque.size();&#x2F;&#x2F;返回容器中元素的个数</p>
<p>deque.empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>deque.resize(num);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">print</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双端插入和删除"><a href="#双端插入和删除" class="headerlink" title="双端插入和删除"></a>双端插入和删除</h2><p>push_back(elem);&#x2F;&#x2F;在容器尾部添加一个数据</p>
<p>push_front(elem);&#x2F;&#x2F;在容器头部插入一个数据</p>
<p>pop_back();&#x2F;&#x2F;删除容器最后一个数据</p>
<p>pop_front();&#x2F;&#x2F;删除容器第一个数据</p>
<p>at(idx);&#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>operator[];&#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>front();&#x2F;&#x2F;返回第一个数据。</p>
<p>back();&#x2F;&#x2F;返回最后一个数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;大小:&quot;</span>&lt;&lt;d.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    <span class="comment">//d.at(4)=90;会报异常</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>插入操作</p>
<p>insert(pos,elem);&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</p>
<p>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值</p>
<p>删除操作</p>
<p>clear();&#x2F;&#x2F;移除容器的所有数据</p>
<p>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(arr,arr+<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>()+<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">end</span>()<span class="number">-3</span>,<span class="number">2</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;::iterator it=d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>()+<span class="number">2</span>,d.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> deque&lt;T&gt; &amp;deq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> deque&lt;T&gt;::const_iterator it=deq.<span class="built_in">begin</span>();it!=deq.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-queue</title>
    <url>/2023/03/24/STL-queue/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的存储空间，有两个口，一个是进入数据，一个是出数据，有先进先出的特性</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>没有迭代器</p>
<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><p>1.构造函数 2.赋值3.数据存取 3.大小操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Maker</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;Maker *&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Maker</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Maker</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">19</span>));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Maker</span>(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Maker *m = q.<span class="built_in">front</span>();</span><br><span class="line">		cout &lt;&lt; m-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m-&gt;age &lt;&lt; endl;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">delete</span> m;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-stack</title>
    <url>/2023/03/24/STL-stack/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的存储空间，只有一个出口，先进后出特性</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>没有迭代器</p>
<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><p>1.构造函数 2.赋值3.数据存取 3.大小操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈容器，先进后出</span></span><br><span class="line"><span class="comment">//存储基础数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出栈中元素</span></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Maker</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存储对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;Maker&gt; s;</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="built_in">Maker</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>));</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="built_in">Maker</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">19</span>));</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="built_in">Maker</span>(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; s.<span class="built_in">top</span>().name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; s.<span class="built_in">top</span>().age &lt;&lt; endl;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-vector</title>
    <url>/2023/03/24/STL-vector/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的储存空间，但在结构上是单口，无法对头部进行操作</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>随机访问迭代器</p>
<h1 id="vector容器动态增长原理"><a href="#vector容器动态增长原理" class="headerlink" title="vector容器动态增长原理"></a>vector容器动态增长原理</h1><p>1.当存储空不够时，会开辟另一块大的空间，然后把数据拷贝过去，最后在销毁原来的空间</p>
<p>2.申请的空间,会比用户需求大一点</p>
<p>3.重新分配空间，那么原来的迭代器就会失效</p>
<h1 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h1><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h2><p>vector <code>&lt;T&gt;</code> v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数</p>
<p>vector(v.begin(), v.end());&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</p>
<p>vector(n, elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p>vector(const vector &amp;vec);&#x2F;&#x2F;拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(arr,arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">Rprint</span>(v);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-赋值操作"><a href="#2-赋值操作" class="headerlink" title="2.赋值操作"></a>2.赋值操作</h2><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<p>vector&amp;operator&#x3D;(const vector  &amp;vec);&#x2F;&#x2F;重载等号操作符</p>
<p>swap(vec);&#x2F;&#x2F; 将vec与本身的元素互换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">6</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">swap</span>(v2);<span class="comment">//最快的方式将指针交换</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-大小操作"><a href="#3-大小操作" class="headerlink" title="3.大小操作"></a>3.大小操作</h2><p>size();&#x2F;&#x2F;返回容器中元素的个数</p>
<p>empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>resize(int num);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>resize(int num, elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</p>
<p>capacity();&#x2F;&#x2F;容器的容量</p>
<p>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.resize开辟空间，并初始化</span></span><br><span class="line">	<span class="comment">//2.reserve开辟空间，但不初始化</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	v2.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line"></span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; v2[10] &lt;&lt; endl;//err,不能访问未初始化的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-reserve的作用"><a href="#4-reserve的作用" class="headerlink" title="4.reserve的作用"></a>4.reserve的作用</h2><p>预开辟空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不写reserve，那么将多次开辟空间</span></span><br><span class="line">    <span class="comment">//v.reserve(100);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>*p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100866666</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p!=&amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p=&amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-swap的作用"><a href="#5-swap的作用" class="headerlink" title="5.swap的作用"></a>5.swap的作用</h2><p>使用匿名对象缩小capacity</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//step1.  v2用来测试</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//vecor拷贝构造，只会赋值，不会将空间复制</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step2. 将step1省略，使用匿名对象</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">//vector&lt;int&gt;(匿名对象)(v).swap(v),匿名先对象调用拷贝构造，将capacity变成10，再与v交换，使得v的capacity变小</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-存取操作"><a href="#6-存取操作" class="headerlink" title="6.存取操作"></a>6.存取操作</h2><p>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</p>
<p>operator[];&#x2F;&#x2F;返回索引idx所指的数据，越界时，运行直接报错</p>
<p>front();&#x2F;&#x2F;返回容器中第一个数据元素</p>
<p>back();&#x2F;&#x2F;返回容器中最后一个数据元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">front</span>() = <span class="number">100</span>;</span><br><span class="line">	v.<span class="built_in">back</span>() = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-插入和删除"><a href="#7-插入和删除" class="headerlink" title="7.插入和删除"></a>7.插入和删除</h2><p>insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele.</p>
<p>push_back(ele); &#x2F;&#x2F;尾部插入元素ele</p>
<p>pop_back();&#x2F;&#x2F;删除最后一个元素</p>
<p>erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</p>
<p>erase(const_iterator pos);&#x2F;&#x2F;删除迭代器指向的元素</p>
<p>clear();&#x2F;&#x2F;删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>,<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="api的注意"><a href="#api的注意" class="headerlink" title="api的注意"></a>api的注意</h1><p>1.resize开辟空间，并初始化。reserve开辟空间，但不初始化.没有初始化的空间不能访问</p>
<p>2.reserve作用：如果容器要存储大量数据时，要先开辟空间，避免多次申请空间</p>
<p>3.swap作用:缩小容器的容量</p>
<h1 id="打印vector"><a href="#打印vector" class="headerlink" title="打印vector"></a>打印vector</h1><p> 该段代码在编译时是会报错的，原因在于iterator为依赖限定名称。在T的实际类型未确定之前，</p>
<p> 编译无法知道iterator是指代类型还是某个静态成员。消除歧义的方法很简单，显式注明iterator为类型名称，</p>
<p> 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;T&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> vector&lt;T&gt;::const_iterator it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rprint</span><span class="params">(vector&lt;T&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> vector&lt;T&gt;::reverse_iterator it=vec.<span class="built_in">rbegin</span>();it!=vec.<span class="built_in">rend</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-list</title>
    <url>/2023/03/24/STL-list/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>双向循环链表</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>双向迭代器</p>
<h1 id="常用pai"><a href="#常用pai" class="headerlink" title="常用pai"></a>常用pai</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>list <code>&lt;T&gt;</code> lstT;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</p>
<p>list(beg,end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>list(n,elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(v.begin()+<span class="number">1</span>,v.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l1</span><span class="params">(l.begin(),--l.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(l);</span><br><span class="line">    <span class="built_in">print</span>(l1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据元素的插入和删除"><a href="#数据元素的插入和删除" class="headerlink" title="数据元素的插入和删除"></a>数据元素的插入和删除</h2><p>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</p>
<p>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</p>
<p>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</p>
<p>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</p>
<p>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</p>
<p>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</p>
<p>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</p>
<p>clear();&#x2F;&#x2F;移除容器的所有数据</p>
<p>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
<p>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val&gt;<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1000</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2000</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">insert</span>(mylist.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">remove</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除特定条件的数,括号内为bool类型判断</span></span><br><span class="line">    mylist.<span class="built_in">remove_if</span>(myfunc);</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h2><p>size();&#x2F;&#x2F;返回容器中元素的个数</p>
<p>empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>resize(num);&#x2F;&#x2F;重新指定容器的长度为num，</p>
<p>若容器变长，则以默认值填充新位置。</p>
<p>如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num，</p>
<p>若容器变长，则以elem值填充新位置。</p>
<p>如果容器变短，则末尾超出容器长度的元素被删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mylist.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; mylist.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mylist.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;kong&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;!kong&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值操作和数据的存取"><a href="#赋值操作和数据的存取" class="headerlink" title="赋值操作和数据的存取"></a>赋值操作和数据的存取</h2><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<p>list&amp;operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符</p>
<p>swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。</p>
<p>front();&#x2F;&#x2F;返回第一个元素。</p>
<p>back();&#x2F;&#x2F;返回最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	mylist.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; mylist.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; mylist.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; mylist2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mylist2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mylist2.<span class="built_in">swap</span>(mylist);</span><br><span class="line">	<span class="built_in">print</span>(mylist2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反转和排序"><a href="#反转和排序" class="headerlink" title="反转和排序"></a>反转和排序</h2><p>reverse();&#x2F;&#x2F;反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</p>
<p>sort(); &#x2F;&#x2F;list排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">、<span class="function"><span class="type">bool</span> <span class="title">myfunc1</span><span class="params">(<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1&gt;val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mylist.<span class="built_in">push_back</span>(i + <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">reverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：list容器不能使用sort算法</span></span><br><span class="line">	<span class="comment">//sort(mylist.begin(), mylist.end());</span></span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">sort</span>(myfunc1);</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> list&lt;T&gt; &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;T&gt;::const_iterator it=l.<span class="built_in">begin</span>();it!=l.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-string</title>
    <url>/2023/03/24/STL-string/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的存储空间，用一个char*指向这片空间</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>随机访问迭代器</p>
<h1 id="常用api及其用法"><a href="#常用api及其用法" class="headerlink" title="常用api及其用法"></a>常用api及其用法</h1><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h2><p>string();&#x2F;&#x2F;创建一个空的字符串 例如: string str;<br>string(const string&amp; str);&#x2F;&#x2F;使用一个string对象初始化另一个string对象<br>string(const char* s);&#x2F;&#x2F;使用字符串s初始化<br>string(int n, char c);&#x2F;&#x2F;使用n个字符c初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;fdsjk&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">20</span>,<span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-基本赋值"><a href="#2-基本赋值" class="headerlink" title="2.基本赋值"></a>2.基本赋值</h2><p>string&amp;operator&#x3D;(const char* s);&#x2F;&#x2F;char*类型字符串 赋值给当前的字符串<br>string&amp;operator&#x3D;(const string&amp;s);&#x2F;&#x2F;把字符串s赋给当前的字符串<br>string&amp;operator&#x3D;(char c);&#x2F;&#x2F;字符赋值给当前的字符串<br>string&amp; assign(const char *s);&#x2F;&#x2F;把字符串s赋给当前的字符串<br>string&amp; assign(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串<br>string&amp; assign(const string&amp;s);&#x2F;&#x2F;把字符串s赋给当前字符串<br>string&amp; assign(int n, char c);&#x2F;&#x2F;用n个字符c赋给当前字符串<br>string&amp; assign(const string&amp;s, int start, int n);&#x2F;&#x2F;将s从start开始n个<br>字符赋值给字符串,如s&#x3D;hello,那么n&#x3D;3,start&#x3D;1，那么是hel中从e开始赋值3-1个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    string s2=s1;</span><br><span class="line">    string s3;</span><br><span class="line">    s3=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">assign</span>(<span class="string">&quot;opopop&quot;</span>);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">assign</span>(<span class="string">&quot;ioioio&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s3.<span class="built_in">assign</span>(s2,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-存取字符"><a href="#3-存取字符" class="headerlink" title="3.存取字符"></a>3.存取字符</h2><p>char&amp;operator[](int n);&#x2F;&#x2F;通过[]方式取字符<br>char&amp; at(int n);&#x2F;&#x2F;通过at方法获取字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(string::iterator it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;s.<span class="built_in">at</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//[]和at的区别：[]访问元素时，越界不抛异常，直接挂，at越界，会抛异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;s[1000];</span></span><br><span class="line">       s.<span class="built_in">at</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(out_of_range &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;ex.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;at越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-拼接"><a href="#4-拼接" class="headerlink" title="4.拼接"></a>4.拼接</h2><p>string&amp;operator+&#x3D;(const string&amp; str);&#x2F;&#x2F;重载+&#x3D;操作符<br>string&amp;operator+&#x3D;(const char* str);&#x2F;&#x2F;重载+&#x3D;操作符<br>string&amp;operator+&#x3D;(const char c);&#x2F;&#x2F;重载+&#x3D;操作符<br>string&amp; append(const char *s);&#x2F;&#x2F;把字符串s连接到当前字符串结尾<br>string&amp; append(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾<br>string&amp; append(const string&amp;s);&#x2F;&#x2F;同operator+&#x3D;()<br>string&amp; append(const string&amp;s, int pos, int n);&#x2F;&#x2F;把字符串s中从pos开始的n个字符连接到当前字符串结尾<br>string&amp; append(int n, char c);&#x2F;&#x2F;在当前字符串结尾添加n个字符c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;uuuuuuuuuu&quot;</span>;</span><br><span class="line">    s+=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    s.<span class="built_in">append</span>(<span class="string">&quot;iiiiiii&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">append</span>(<span class="string">&quot;yyyyyy&quot;</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-查找和替换"><a href="#5-查找和替换" class="headerlink" title="5.查找和替换"></a>5.查找和替换</h2><p>int find(const string&amp; str, int pos &#x3D; 0) const; &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找<br>int find(constchar* s, int pos &#x3D; 0) const;  &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找<br>int find(constchar* s, int pos, int n) const;  &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置<br>int find(constchar c, int pos &#x3D; 0) const;  &#x2F;&#x2F;查找字符c第一次出现位置<br>int rfind(conststring&amp; str, int pos &#x3D; npos) const;&#x2F;&#x2F;查找str最后一次位置,从pos开始查找<br>int rfind(constchar* s, int pos &#x3D; npos) const;&#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找<br>int rfind(constchar* s, int pos, int n) const;&#x2F;&#x2F;从pos查找s的前n个字符最后一次位置<br>int rfind(constchar c, int pos &#x3D; 0) const; &#x2F;&#x2F;查找字符c最后一次出现位置<br>string&amp; replace(int pos, int n, const string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str<br>string&amp; replace(int pos, int n, const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串s</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;abcdefghijak&quot;</span>;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">find</span>(<span class="string">&#x27;f&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">find</span>(<span class="string">&quot;cdiiiii&quot;</span>,<span class="number">0</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">rfind</span>(<span class="string">&#x27;a&#x27;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//将4个元素替换成123</span></span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-比较"><a href="#6-比较" class="headerlink" title="6.比较"></a>6.比较</h2><p>compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。<br>比较区分大小写，比较时参考字典顺序，排越前面的越小。<br>大写的A比小写的a小。</p>
<p>int compare(const string&amp;s) const;&#x2F;&#x2F;与字符串s比较<br>int compare(const char *s) const;&#x2F;&#x2F;与字符串s比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;aaabc&quot;</span>;</span><br><span class="line">    string s2=<span class="string">&quot;aAabc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s1.<span class="built_in">compare</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-子串"><a href="#7-子串" class="headerlink" title="7.子串"></a>7.子串</h2><p>子串<br>string substr(int pos &#x3D; 0, int n &#x3D; npos) const;&#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;123456@xx.email&quot;</span>;</span><br><span class="line">    string s1=s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    string s2=s.<span class="built_in">substr</span>(<span class="number">7</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-插入和删除"><a href="#8-插入和删除" class="headerlink" title="8.插入和删除"></a>8.插入和删除</h2><p>string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串<br>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串<br>string&amp; insert(int pos, int n, char c);&#x2F;&#x2F;在指定位置插入n个字符c<br>string&amp; erase(int pos, int n &#x3D; npos);&#x2F;&#x2F;删除从Pos开始的n个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-string和const-char-转换"><a href="#9-string和const-char-转换" class="headerlink" title="9.string和const char*转换"></a>9.string和const char*转换</h2><p>string和c-style字符串转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;12345676678&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* s1=s.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">   string s2=<span class="built_in">string</span>(s1);</span><br><span class="line">   cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-用迭代器遍历字符"><a href="#10-用迭代器遍历字符" class="headerlink" title="10.用迭代器遍历字符"></a>10.用迭代器遍历字符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;9999888777&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(string::iterator it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//反向遍历  反向迭代器string::reverse_iterator</span></span><br><span class="line">    <span class="keyword">for</span>(string::reverse_iterator it=s.<span class="built_in">rbegin</span>();it!=s.<span class="built_in">rend</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">         cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常用的api中的注意"><a href="#常用的api中的注意" class="headerlink" title="常用的api中的注意"></a>常用的api中的注意</h1><p>1.[]和at区别：[]如果越界，不抛异常，直接挂。at会抛异常</p>
<p>2.字符串内存重新分配，[]和at获取的字符引用，再次使用时，可以能会出错</p>
<p>3.string和char *的区别：string是一个类，char *是一个指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="type">char</span> &amp;a=s[<span class="number">3</span>];<span class="comment">//s[3]返回的是引用</span></span><br><span class="line">    <span class="type">char</span> &amp;b=s[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    a=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s原地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)s.<span class="built_in">c_str</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a原地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)&amp;a&lt;&lt;endl;</span><br><span class="line">    s=<span class="string">&quot;ppppppppppppppppppppppppppp&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s新地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)s.<span class="built_in">c_str</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a现地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)&amp;a&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//原空间被释放，如果还是操作a，b则是非法空间操作</span></span><br><span class="line">    a=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2023/03/26/Alrithmetic_Binary_find/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>折半查找，每次一半查找。</p>
<h1 id="查找出现的第一个位置"><a href="#查找出现的第一个位置" class="headerlink" title="查找出现的第一个位置"></a>查找出现的第一个位置</h1><p><a href="https://cloudimge.com/image/nasys"><img src="https://c.1ovv.com/2023/03/26/nasys.md.jpeg" alt="nasys.md.jpeg" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//check为某种约束条例，第一个check找的是右区间，寻找第一个x出现位置，第二个check寻找最后一个check</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> mid,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[mid]&gt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_find</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a,mid,x))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找出现的最后一个位置"><a href="#查找出现的最后一个位置" class="headerlink" title="查找出现的最后一个位置"></a>查找出现的最后一个位置</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check1</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> mid,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[mid]&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_find1</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;<span class="comment">//如果不加1会死循环，例如l=r-1，则mid=l;那么更新l则会是l=l;会死循环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check1</span>(a,mid,x))l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2023/03/26/Arithmetic_Merge_Sort/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序(MERGE-SORT)是建立在归并操作上的一种有效的排序算法,该算法是采用分治法 (Divide and Conquer)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序 列;即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二 路归并。 归并排序核心步骤:</p>
<p><a href="https://cloudimge.com/image/nacFm"><img src="https://c.1ovv.com/2023/03/26/nacFm.md.jpeg" alt="nacFm.md.jpeg" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<h1 id="归并-递归"><a href="#归并-递归" class="headerlink" title="归并-递归"></a>归并-递归</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,left,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index[right-left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])index[k++]=a[i++];<span class="comment">//注意是小于等于哦</span></span><br><span class="line">        <span class="keyword">else</span> index[k++]=a[j++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)index[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)index[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left,k=<span class="number">0</span>;i&lt;=right;i++,k++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=index[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并-非递归"><a href="#归并-非递归" class="headerlink" title="归并-非递归"></a>归并-非递归</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">1</span>;<span class="comment">//控制每组数据</span></span><br><span class="line">	<span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//[i,i+gap-1][i+gap,i+2*gap-1]   每组gap个 i+gap刚好跳到下一组第一个，所以减一为上一组最后一个</span></span><br><span class="line">			<span class="comment">//归并</span></span><br><span class="line">			<span class="type">int</span> begin1 = i, end1 = i+gap<span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> begin2 =i+gap, end2 = i+<span class="number">2</span>*gap<span class="number">-1</span>;</span><br><span class="line">			<span class="comment">//归并过程中，右半区间不存在</span></span><br><span class="line">			<span class="keyword">if</span> (begin2 &gt;= n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">//右半区间算多了</span></span><br><span class="line">			<span class="keyword">if</span> (end2 &gt;= n)</span><br><span class="line">				end2 = n - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> index = i;</span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) <span class="comment">//注意且不是或</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">				&#123;</span><br><span class="line">					temp[index++] = a[begin1++];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					temp[index++] = a[begin2++];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[index++] = a[begin1++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[index++] = a[begin2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//拷贝回去,为了保证不将越界拷贝进来（右半区间不存在，不完整，左半区间不完整等  在前面循环已经有序，故在原数组有序不用理会），故使用每次循环拷贝</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;=end2; j++)<span class="comment">//注意不能写begin1  毕竟前面在++</span></span><br><span class="line">			&#123;</span><br><span class="line">				a[j] = temp[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
</search>
