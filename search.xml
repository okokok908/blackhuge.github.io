<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二分查找</title>
    <url>/2023/03/26/Arithmetic_Binary_find/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>折半查找，每次一半查找。</p>
<h1 id="查找出现的第一个位置"><a href="#查找出现的第一个位置" class="headerlink" title="查找出现的第一个位置"></a>查找出现的第一个位置</h1><p><a href="https://cloudimge.com/image/nasys"><img src="https://c.1ovv.com/2023/03/26/nasys.md.jpeg" alt="nasys.md.jpeg" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//check为某种约束条例，第一个check找的是右区间，寻找第一个x出现位置，第二个check寻找最后一个check</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> mid,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[mid]&gt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_find</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a,mid,x))r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找出现的最后一个位置"><a href="#查找出现的最后一个位置" class="headerlink" title="查找出现的最后一个位置"></a>查找出现的最后一个位置</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check1</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> mid,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[mid]&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_find1</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;<span class="comment">//如果不加1会死循环，例如l=r-1，则mid=l;那么更新l则会是l=l;会死循环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check1</span>(a,mid,x))l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度算法</title>
    <url>/2023/04/04/Arithmetic_HighPrecision/</url>
    <content><![CDATA[<h1 id="High-Precision"><a href="#High-Precision" class="headerlink" title="High Precision"></a>High Precision</h1><h1 id="什么是高精度"><a href="#什么是高精度" class="headerlink" title="什么是高精度"></a>什么是高精度</h1><p>有时，我们要做特别大数据的计算。多大呢？几百万位，远远超过了long long的数据范围，直接用long long肯定会溢出。这时候我们就要用高精度算法\nPS：python自带高精度。</p>
<h1 id="所有高精度算法的原理"><a href="#所有高精度算法的原理" class="headerlink" title="所有高精度算法的原理"></a>所有高精度算法的原理</h1><p>大体的思路，就是用字符数组（因为字符数组可以达到一个下标对应一个数字，达到按位处理的目的），然后转到整形数组（整型数组才能进行计算）一个下标对应一个数字，用另一个数组进行按位相加。</p>
<h1 id="常见的高精度算法"><a href="#常见的高精度算法" class="headerlink" title="常见的高精度算法"></a>常见的高精度算法</h1><p><strong>注意：</strong></p>
<p>​	一个大数通过字符串方式读入(s[i]-‘0’),转化为数字。</p>
<p>​	通常情况下，为了方便进位数字低位放入低下标，高位放高下标(例如1234 放入数组中应是4321)。这里只是说通常情况下，例如乘法时就应顺着放，凡是为了统一，反着放。</p>
<h2 id="高精度加法（大数加大数）"><a href="#高精度加法（大数加大数）" class="headerlink" title="高精度加法（大数加大数）"></a>高精度加法（大数加大数）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; k;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()||i&lt;b.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;a.<span class="built_in">size</span>())c+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>())c+=b[i];</span><br><span class="line">        k.<span class="built_in">push_back</span>(c%<span class="number">10</span>);</span><br><span class="line">        c/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c)k.<span class="built_in">push_back</span>(c);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="高精度减法（大数-大数）"><a href="#高精度减法（大数-大数）" class="headerlink" title="高精度减法（大数-大数）"></a>高精度减法（大数-大数）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span><span class="comment">//这里的大数减法，默认a&gt;b，所以用一个cmp函数来判断a与b谁大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">            <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k=a[i]-k;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>())k-=b[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>((k+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=<span class="number">0</span>)k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> k=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>)c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度乘法（大数-数）"><a href="#高精度乘法（大数-数）" class="headerlink" title="高精度乘法（大数*数）"></a>高精度乘法（大数*数）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;<span class="comment">//进位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()||k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;a.<span class="built_in">size</span>())k+=a[i]*b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(k%<span class="number">10</span>);</span><br><span class="line">        k/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>)c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度除法（大数-x2F-数）"><a href="#高精度除法（大数-x2F-数）" class="headerlink" title="高精度除法（大数&#x2F;数）"></a>高精度除法（大数&#x2F;数）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;c;</span><br><span class="line">    r=<span class="number">0</span>;<span class="comment">//借位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r=a[i]+r*<span class="number">10</span>;</span><br><span class="line">        c.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;c.<span class="built_in">back</span>()==<span class="number">0</span>)c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2023/03/26/Arithmetic_Merge_Sort/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序(MERGE-SORT)是建立在归并操作上的一种有效的排序算法,该算法是采用分治法 (Divide and Conquer)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序 列;即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二 路归并。 归并排序核心步骤:</p>
<p><a href="https://cloudimge.com/image/nacFm"><img src="https://c.1ovv.com/2023/03/26/nacFm.md.jpeg" alt="nacFm.md.jpeg" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<h1 id="归并-递归"><a href="#归并-递归" class="headerlink" title="归并-递归"></a>归并-递归</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid=left+right&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,left,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,mid+<span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index[right-left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])index[k++]=a[i++];<span class="comment">//注意是小于等于哦</span></span><br><span class="line">        <span class="keyword">else</span> index[k++]=a[j++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)index[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)index[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left,k=<span class="number">0</span>;i&lt;=right;i++,k++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=index[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并-非递归"><a href="#归并-非递归" class="headerlink" title="归并-非递归"></a>归并-非递归</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">1</span>;<span class="comment">//控制每组数据</span></span><br><span class="line">	<span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//[i,i+gap-1][i+gap,i+2*gap-1]   每组gap个 i+gap刚好跳到下一组第一个，所以减一为上一组最后一个</span></span><br><span class="line">			<span class="comment">//归并</span></span><br><span class="line">			<span class="type">int</span> begin1 = i, end1 = i+gap<span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span> begin2 =i+gap, end2 = i+<span class="number">2</span>*gap<span class="number">-1</span>;</span><br><span class="line">			<span class="comment">//归并过程中，右半区间不存在</span></span><br><span class="line">			<span class="keyword">if</span> (begin2 &gt;= n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">//右半区间算多了</span></span><br><span class="line">			<span class="keyword">if</span> (end2 &gt;= n)</span><br><span class="line">				end2 = n - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> index = i;</span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) <span class="comment">//注意且不是或</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">				&#123;</span><br><span class="line">					temp[index++] = a[begin1++];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					temp[index++] = a[begin2++];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[index++] = a[begin1++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[index++] = a[begin2++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//拷贝回去,为了保证不将越界拷贝进来（右半区间不存在，不完整，左半区间不完整等  在前面循环已经有序，故在原数组有序不用理会），故使用每次循环拷贝</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;=end2; j++)<span class="comment">//注意不能写begin1  毕竟前面在++</span></span><br><span class="line">			&#123;</span><br><span class="line">				a[j] = temp[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和 差分</title>
    <url>/2023/04/04/Arithmetic_PrefixAnd_Difference/</url>
    <content><![CDATA[<h1 id="前缀和-差分"><a href="#前缀和-差分" class="headerlink" title="前缀和-差分"></a>前缀和-差分</h1><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化</p>
<p><img src="/img/images/qzh1.png" alt="qzh1" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>前缀和算法有什么好处</strong></p>
<p>输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。我们很容易想出暴力解法，遍历区间求和。</p>
<p>但这样的时间复杂度为O(n * m)，如果n和m的数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到O(n + m)，大大提高了运算效率。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>前缀和</strong>和<strong>差分</strong>都是数组下标以<strong>1</strong>开始。</p>
<h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以简写为</span></span><br><span class="line"><span class="comment">//a[N]是原数组，那么其前缀和为a[i]+=a[i-1]；</span></span><br></pre></td></tr></table></figure>

<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>先给出问题：</p>
<p>​	输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p>
<p>​	同一维前缀和一样，我们先来定义一个二维数组s[][] , s[i][j] 表示二维数组中，左上角(1, 1)到右下角(i, j)所包围的矩阵元素的和。接下来推导二维前缀和的公式。</p>
<p><img src="/img/images/qzh2.png" alt="qzh2" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>从图中我们很容易看出，整个外围蓝色矩形面积s[i][j] &#x3D; 绿色面积s[i - 1][j] + 紫色面积s[i][j - 1] - 重复加的红色的面积s[i - 1][j - 1] + 小方块的面积a[i][j];</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[i][j] = s[i - 1][j] + s[i][j - 1 ] + a[i] [j] - s[i - 1][j - 1]</span><br></pre></td></tr></table></figure>

<p>那么接下来看如何求子矩阵面积：</p>
<p><img src="/img/images/qzh3.png" alt="qzh3" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - <span class="number">1</span>] - 紫色面积s[x1 - <span class="number">1</span>, y2] + 重复减去的红色面积 s[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">因此二维前缀和的结论为：</span><br><span class="line"></span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">s[x2, y2] - s[x1 - <span class="number">1</span>, y2] - s[x2, y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>例题</strong></p>
<p>输入一个 n行 m列的整数矩阵，再输入 q个询问，每个询问包含四个整数 x1,y1,x2,y2表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个整数 n，m，q</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q行，每行包含四个整数 x1,y1,x2,y2表示一组询问。</p>
<p><strong>输出格式</strong></p>
<p>共 q 行，每行输出一个询问的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            a[i][j]+=a[i][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        cout&lt;&lt;a[x2][y2]-a[x2][y1<span class="number">-1</span>]-a[x1<span class="number">-1</span>][y2]+a[x1<span class="number">-1</span>][y1<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>定义两个数组a[N],b[N]，则数组a为数组b的前缀和(例如:a[i]&#x3D;b[0]+b[1]+b[2]……+b[i])，那么数组b就是a的差分（例如：b[1]&#x3D;a[1]-a[0],b[2]&#x3D;a[2]-a[1],b[3]&#x3D;a[3]-a[2]……)</p>
<p><img src="/img/images/cf1.png" alt="cf1" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p><strong>前缀和</strong>和<strong>差分</strong>都是数组下标以<strong>1</strong>开始。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>若初始时数组a和数组b都为0，那么对数组a赋值也就是对数组b的每个[i,i]区间加上a[i],又因为数组a和数组b初始时都为0，即数组b也就是数组a，数组a也就是数组b，那么将数组a当做数组b即可，所以只需定义一个数组a，不必开辟数组b，二维数组同理。</p>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p>若想对数组a中的某个区间[l,r]加上c，那么只需让其对应差分b[l]+c,b[r+1]-c即可</p>
<p><img src="/img/images/cf2.png" alt="cf2" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure>

<p><strong>插入操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x]+=c;</span><br><span class="line">    b[y+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>若想将某个子矩阵[x1,y1]-[x2,y2] (对角线)加上c</p>
<p><img src="/img/images/cf3.png" alt="cf3" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b[x1][y1] += c ; 对应图<span class="number">1</span> ,让整个a数组中蓝色矩形面积的元素都加上了c。</span><br><span class="line">b[x1,][y2 + <span class="number">1</span>] -= c ; 对应图<span class="number">2</span> ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。</span><br><span class="line">b[x2 + <span class="number">1</span>][y1] -= c ; 对应图<span class="number">3</span> ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。</span><br><span class="line">b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c; 对应图<span class="number">4</span>,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。</span><br></pre></td></tr></table></figure>



<p><img src="/img/images/cf4.png" alt="cf4" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>ps:</p>
<p>​	对二维数组求前缀和前面已描述</p>
<p><strong>例题</strong></p>
<p>输入一个 n行 m列的整数矩阵，再输入 q个操作，每个操作包含五个整数 x1,y1,x2,y2,c其中 (x1,y1)和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 n,m,q</p>
<p>接下来 n行，每行包含 m个整数，表示整数矩阵。</p>
<p>接下来 q行，每行包含 55 个整数 x1,y1,x2,y2,c表示一个操作。</p>
<p><strong>输出格式</strong></p>
<p>共 n行，每行 m个整数，表示所有操作进行完毕后的最终矩阵。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cout&lt;&lt;b[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2023/03/25/Arithmetic_Quick_Sort/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为:任取待排序 元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有 元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所 有元素都排列在相应位置上为止。<br><strong>将区间按照基准值划分为左右两半部分的常见方式有:</strong></p>
<p><strong>1.挖坑法 2.左右指针法 3.前后指针法</strong></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>O(N*log 	N)</strong></p>
<p><a href="https://cloudimge.com/image/nzVKR"><img src="https://c.1ovv.com/2023/03/25/nzVKR.md.jpeg" alt="nzVKR.md.jpeg" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>不稳定排序</p>
<h1 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h1><p><a href="https://cloudimge.com/image/nzdjd"><img src="https://c.1ovv.com/2023/03/25/nzdjd.md.png" alt="nzdjd.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<p>先讲左端或右端的值设定为key,key右边的值比key大，左边的值比key小，也就是说end–的行动方式为&gt;a[key]，同理左边的行动方式为&lt;a[key]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挖坑法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将中间值置换到begin位置，解决有序最坏的情况</span></span><br><span class="line">	<span class="type">int</span> mid = <span class="built_in">GetMidIndex</span>(a, left, right);</span><br><span class="line">	<span class="built_in">swap</span>(a[left], a[mid]);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = left, end = right;</span><br><span class="line">	<span class="type">int</span> key = a[begin];</span><br><span class="line">	<span class="type">int</span> pivot = begin;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//右边找小，放到左边</span></span><br><span class="line">		<span class="keyword">while</span> (a[end] &gt;= key &amp;&amp; begin &lt; end)<span class="comment">//判断范围加全，避免在--的过程中，end&lt;begin 注意是&gt;=  ＝一定要加上不然容易死循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//小的放到左边坑位，自己形成新的坑位</span></span><br><span class="line">		a[pivot] = a[end];</span><br><span class="line">		pivot = end;</span><br><span class="line">		<span class="comment">//左边找大，放到右边</span></span><br><span class="line">		<span class="keyword">while</span> (a[begin] &lt;= key &amp;&amp; begin &lt; end)</span><br><span class="line">		&#123;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">		a[pivot] = a[begin];</span><br><span class="line">		pivot = begin;</span><br><span class="line">	&#125;</span><br><span class="line">	pivot = begin;</span><br><span class="line">	a[begin] = key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前后指针法"><a href="#前后指针法" class="headerlink" title="前后指针法"></a>前后指针法</h1><p><a href="https://cloudimge.com/image/nzfL4"><img src="https://c.1ovv.com/2023/03/25/nzfL4.md.png" alt="nzfL4.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前后指针法 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> prev = left, cur = left + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> keyi = left;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[cur] &lt;= a[keyi] &amp;&amp; ++prev != cur)<span class="comment">//注意是前置++    ++prev != cur 防止自己与自己交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			prev++;</span><br><span class="line">			<span class="built_in">Swap</span>(&amp;a[prev], &amp;a[cur]);</span><br><span class="line">		&#125;</span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Swap</span>(&amp;a[keyi], &amp;a[prev]);</span><br><span class="line">	keyi = prev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> keyi;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="左右指针法"><a href="#左右指针法" class="headerlink" title="左右指针法"></a>左右指针法</h1><p>同挖洞法，左边找大，右边找小，然后交换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挖坑法类似，，左右指针法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//将中间值置换到begin位置，解决有序最坏的情况</span></span><br><span class="line">	<span class="type">int</span> mid = <span class="built_in">GetMidIndex</span>(a, left, right);</span><br><span class="line">	<span class="built_in">swap</span>(a[left], a[mid]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> begin = left, end = right;</span><br><span class="line">	<span class="type">int</span> keyi = begin;</span><br><span class="line">	<span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end &amp;&amp; a[end] &gt;= a[keyi])</span><br><span class="line">		&#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end &amp;&amp; a[begin] &lt;= a[keyi])</span><br><span class="line">		&#123;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(a[begin], a[end]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(a[keyi], a[begin]);</span><br><span class="line">	keyi = begin;</span><br><span class="line">	<span class="keyword">return</span> keyi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三数取中"><a href="#三数取中" class="headerlink" title="三数取中"></a>三数取中</h1><p><a href="https://cloudimge.com/image/nzrvW"><img src="https://c.1ovv.com/2023/03/25/nzrvW.md.png" alt="nzrvW.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<p>若不采用三数取中，时间复杂度为n^2；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMidIndex</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (a[left] &gt; a[mid])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &gt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[left] &gt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//a[left] &lt; a[mid]</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[left] &lt; a[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="上述方法的主函数"><a href="#上述方法的主函数" class="headerlink" title="上述方法的主函数"></a>上述方法的主函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> KeyIndex = <span class="built_in">PartSort3</span>(a, left, right);</span><br><span class="line">	<span class="comment">//[left,right]</span></span><br><span class="line">	<span class="comment">//[left,KeyIndex-1]KeyIndex[KeyIndex+1,right]</span></span><br><span class="line">	<span class="comment">////左右子区间有序了，那么整个数组有序， 怎么有序 分而自治</span></span><br><span class="line">	<span class="comment">//QuickSort(a, left, KeyIndex - 1);</span></span><br><span class="line">	<span class="comment">//QuickSort(a, KeyIndex + 1, right);</span></span><br><span class="line">	<span class="comment">//又因为一直左右区间分，最后每个区间排 浪费数据量太小，没必要再调用快空间，增加消耗   故采用小区间优化(效果不明显，几毫秒的作用）</span></span><br><span class="line">		<span class="built_in">QuickSort</span>(a, left, KeyIndex - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">QuickSort</span>(a, KeyIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="快排非递归"><a href="#快排非递归" class="headerlink" title="快排非递归"></a>快排非递归</h1><p>通过模拟栈来划分左右区间，一定是右边界先入栈，然后左边界，对每个区间都是如此，这样取得时候就是先取左边界</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/快排非递归</span><br><span class="line"><span class="comment">//快速排序非递归</span></span><br><span class="line"><span class="comment">//递归的缺陷？： ，递归深度太深，栈空间不够，容易造成栈溢出</span></span><br><span class="line"><span class="comment">//递归改非递归：1、(一般简单递归）直接改循环2、借助数据结构栈模拟递归过程（复杂递归)/////需要栈///队列也可以模拟</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="comment">//栈先进后出，故先进右区间点，再进左区间点</span></span><br><span class="line">    st.<span class="built_in">push</span>(n<span class="number">-1</span>);</span><br><span class="line">	st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> right = st.<span class="built_in">top</span>();</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> KeyIndex = <span class="built_in">PartSort1</span>(a, left, right);</span><br><span class="line">		<span class="comment">//[left,KeyIndex] KeyIndex[KeyIndex+1,right]</span></span><br><span class="line">		<span class="comment">//先判断左区间，再判断右区间，所以先入右区间，再入左区间</span></span><br><span class="line">		<span class="keyword">if</span> (KeyIndex + <span class="number">1</span> &lt; right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//先入右区间点，再入左区间点</span></span><br><span class="line">			st.<span class="built_in">push</span>(right);</span><br><span class="line">			st.<span class="built_in">push</span>(KeyIndex+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (left &lt; KeyIndex - <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.<span class="built_in">push</span>(KeyIndex - <span class="number">1</span>);</span><br><span class="line">			st.<span class="built_in">push</span>(left);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="优化方案-采取左右指针"><a href="#优化方案-采取左右指针" class="headerlink" title="优化方案-采取左右指针"></a>优化方案-采取左右指针</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Arithmetic</category>
      </categories>
      <tags>
        <tag>Arithmetic</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-deque</title>
    <url>/2023/03/24/STL-deque/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>逻辑上是连续的存储空间，实际上是由很多块定量的块空间，通过中控器连接起来</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>随机访问迭代器</p>
<h1 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>deque <code>&lt;T&gt;</code> deqT;&#x2F;&#x2F;默认构造形式</p>
<p>deque(beg, end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>deque(n, elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p>deque(const deque &amp;deq);&#x2F;&#x2F;拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(arr,arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">10</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<p>deque&amp;operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符</p>
<p>swap(deq);&#x2F;&#x2F; 将deq与本身的元素互换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    d1.<span class="built_in">assign</span>(arr,arr+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">print</span>(d1);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">swap</span>(d1);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    <span class="built_in">print</span>(d1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>deque.size();&#x2F;&#x2F;返回容器中元素的个数</p>
<p>deque.empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>deque.resize(num);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (d.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">print</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双端插入和删除"><a href="#双端插入和删除" class="headerlink" title="双端插入和删除"></a>双端插入和删除</h2><p>push_back(elem);&#x2F;&#x2F;在容器尾部添加一个数据</p>
<p>push_front(elem);&#x2F;&#x2F;在容器头部插入一个数据</p>
<p>pop_back();&#x2F;&#x2F;删除容器最后一个数据</p>
<p>pop_front();&#x2F;&#x2F;删除容器第一个数据</p>
<p>at(idx);&#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>operator[];&#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>front();&#x2F;&#x2F;返回第一个数据。</p>
<p>back();&#x2F;&#x2F;返回最后一个数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;大小:&quot;</span>&lt;&lt;d.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    <span class="comment">//d.at(4)=90;会报异常</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p>插入操作</p>
<p>insert(pos,elem);&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</p>
<p>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值</p>
<p>删除操作</p>
<p>clear();&#x2F;&#x2F;移除容器的所有数据</p>
<p>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(arr,arr+<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>()+<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    d.<span class="built_in">insert</span>(d.<span class="built_in">end</span>()<span class="number">-3</span>,<span class="number">2</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;::iterator it=d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>()+<span class="number">2</span>,d.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> deque&lt;T&gt; &amp;deq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> deque&lt;T&gt;::const_iterator it=deq.<span class="built_in">begin</span>();it!=deq.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-list</title>
    <url>/2023/03/24/STL-list/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>双向循环链表</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>双向迭代器</p>
<h1 id="常用pai"><a href="#常用pai" class="headerlink" title="常用pai"></a>常用pai</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>list <code>&lt;T&gt;</code> lstT;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</p>
<p>list(beg,end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>list(n,elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p>list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(v.begin()+<span class="number">1</span>,v.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l1</span><span class="params">(l.begin(),--l.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(l);</span><br><span class="line">    <span class="built_in">print</span>(l1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据元素的插入和删除"><a href="#数据元素的插入和删除" class="headerlink" title="数据元素的插入和删除"></a>数据元素的插入和删除</h2><p>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</p>
<p>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</p>
<p>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</p>
<p>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</p>
<p>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</p>
<p>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</p>
<p>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</p>
<p>clear();&#x2F;&#x2F;移除容器的所有数据</p>
<p>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
<p>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val&gt;<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	mylist.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line">	mylist.<span class="built_in">push_front</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1000</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2000</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">insert</span>(mylist.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">remove</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除特定条件的数,括号内为bool类型判断</span></span><br><span class="line">    mylist.<span class="built_in">remove_if</span>(myfunc);</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作"></a>大小操作</h2><p>size();&#x2F;&#x2F;返回容器中元素的个数</p>
<p>empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>resize(num);&#x2F;&#x2F;重新指定容器的长度为num，</p>
<p>若容器变长，则以默认值填充新位置。</p>
<p>如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num，</p>
<p>若容器变长，则以elem值填充新位置。</p>
<p>如果容器变短，则末尾超出容器长度的元素被删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mylist.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; mylist.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mylist.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;kong&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;!kong&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值操作和数据的存取"><a href="#赋值操作和数据的存取" class="headerlink" title="赋值操作和数据的存取"></a>赋值操作和数据的存取</h2><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<p>list&amp;operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符</p>
<p>swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。</p>
<p>front();&#x2F;&#x2F;返回第一个元素。</p>
<p>back();&#x2F;&#x2F;返回最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	mylist.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; mylist.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; mylist.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; mylist2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mylist2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mylist2.<span class="built_in">swap</span>(mylist);</span><br><span class="line">	<span class="built_in">print</span>(mylist2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反转和排序"><a href="#反转和排序" class="headerlink" title="反转和排序"></a>反转和排序</h2><p>reverse();&#x2F;&#x2F;反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</p>
<p>sort(); &#x2F;&#x2F;list排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">、<span class="function"><span class="type">bool</span> <span class="title">myfunc1</span><span class="params">(<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1&gt;val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mylist.<span class="built_in">push_back</span>(i + <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">reverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：list容器不能使用sort算法</span></span><br><span class="line">	<span class="comment">//sort(mylist.begin(), mylist.end());</span></span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line"></span><br><span class="line">    mylist.<span class="built_in">sort</span>(myfunc1);</span><br><span class="line">    <span class="built_in">print</span>(mylist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> list&lt;T&gt; &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;T&gt;::const_iterator it=l.<span class="built_in">begin</span>();it!=l.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Map/MultiMap</title>
    <url>/2023/03/28/STL-map_multimap/</url>
    <content><![CDATA[<h1 id="Map-x2F-MultiMap"><a href="#Map-x2F-MultiMap" class="headerlink" title="Map&#x2F;MultiMap"></a>Map&#x2F;MultiMap</h1><p>map&#x2F;multimap也是关联式容器，容器自身有规则，通过键值排序，map容器中的元素是对组，对组的第一个元素是键值，不能改变，第二个元素是实值，可以改变</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>平衡二叉树</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>双向迭代器</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>map容器和multimap容器的区别是multimap允许有相同的元素</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>set<code>&lt;T&gt;</code> st;&#x2F;&#x2F;set默认构造函数：</p>
<p>mulitset<code>&lt;T&gt;</code> mst; &#x2F;&#x2F;multiset默认构造函数:</p>
<p>set(const set &amp;st);&#x2F;&#x2F;拷贝构造函数</p>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>set&amp;operator&#x3D;(const set &amp;st);&#x2F;&#x2F;重载等号操作符</p>
<p>swap(st);&#x2F;&#x2F;交换两个集合容器</p>
<h1 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h1><p>size();&#x2F;&#x2F;返回容器中元素的数目</p>
<p>empty();&#x2F;&#x2F;判断容器是否为空</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>find(key);&#x2F;&#x2F;查找键key是否存在,若存在，返回该键的元素的迭代器；&#x2F;若不存在，返回map.end();</p>
<p>count(keyElem);&#x2F;&#x2F;返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</p>
<p>lower_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;&#x3D;keyElem元素的迭代器。</p>
<p>upper_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。</p>
<p>equal_range(keyElem);&#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">	mymap[<span class="number">1</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">	mymap[<span class="number">2</span>] = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">	mymap[<span class="number">3</span>] = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line">	mymap[<span class="number">4</span>] = <span class="string">&quot;ddd&quot;</span>;</span><br><span class="line">	mymap[<span class="number">5</span>] = <span class="string">&quot;eee&quot;</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::iterator it = mymap.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line">    	<span class="keyword">if</span> (it == mymap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找大于等于3的最小的数</span></span><br><span class="line">	it = mymap.<span class="built_in">lower_bound</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == mymap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找大于3的最小的数</span></span><br><span class="line">	it = mymap.<span class="built_in">upper_bound</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == mymap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//返回大于等于2的两个最小的数，如果有2那么就返回2和大于2的最小数</span></span><br><span class="line">	pair&lt;map&lt;<span class="type">int</span>,string&gt;::iterator,map&lt;<span class="type">int</span>,string&gt;::iterator&gt; ret=mymap.<span class="built_in">equal_range</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret.first != mymap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot; Value:&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret.second != mymap.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; ret.second-&gt;first &lt;&lt; <span class="string">&quot; Value:&quot;</span> &lt;&lt; ret.second-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>插入数据元素操作</p>
<p>map.insert(…); &#x2F;&#x2F;往容器插入元素，返回pair&lt;iterator,bool&gt;</p>
<p>map&lt;int, string&gt; mapStu;</p>
<p>&#x2F;&#x2F; 第一种 通过pair的方式插入对象</p>
<p>mapStu.insert(pair&lt;int, string&gt;(3, “小张”));</p>
<p>&#x2F;&#x2F; 第二种 通过pair的方式插入对象</p>
<p>mapStu.inset(make_pair(-1, “校长”));</p>
<p>&#x2F;&#x2F; 第三种 通过value_type的方式插入对象</p>
<p>mapStu.insert(map&lt;int, string&gt;::value_type(1, “小李”));</p>
<p>&#x2F;&#x2F; 第四种 通过数组的方式插入值</p>
<p>mapStu[3] &#x3D; “小刘”;</p>
<p>mapStu[5] &#x3D; “小王”;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;haha&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&quot;opop&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>,<span class="string">&quot;uiui&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">5</span>]=<span class="string">&quot;shushu&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(m);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：[]方式插入数据,如果没有实值，那么键值也是存在的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.</span></span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">	<span class="comment">//2.</span></span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">	<span class="comment">//3.</span></span><br><span class="line">	mymap.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>, <span class="string">&quot;ccc&quot;</span>));</span><br><span class="line">	<span class="comment">//4.</span></span><br><span class="line">	mymap[<span class="number">4</span>] = <span class="string">&quot;ddd&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(mymap);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; mymap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; mymap[<span class="number">100</span>] &lt;&lt; endl;<span class="comment">//插入键值，返回的是实值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; mymap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>clear();&#x2F;&#x2F;清除所有元素</p>
<p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</p>
<p>erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
<h1 id="改变规则"><a href="#改变规则" class="headerlink" title="改变规则"></a>改变规则</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">myfunc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> k1,<span class="type">int</span> k2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k1&gt;k2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,string,myfunc&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;haha&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&quot;opop&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>,<span class="string">&quot;uiui&quot;</span>));</span><br><span class="line"></span><br><span class="line">    m[<span class="number">5</span>]=<span class="string">&quot;shushu&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(m);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Pair对组</title>
    <url>/2023/03/28/STL-pair/</url>
    <content><![CDATA[<h1 id="Pair对组"><a href="#Pair对组" class="headerlink" title="Pair对组"></a>Pair对组</h1><p>1.pair对组是一个类，类中有两个共有成员变量，&lt;first,second&gt;</p>
<p>2.对组通常用来接收key-value这样的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,string&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;qw&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;p.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p.second&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-queue</title>
    <url>/2023/03/24/STL-queue/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的存储空间，有两个口，一个是进入数据，一个是出数据，有先进先出的特性</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>没有迭代器</p>
<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><p>1.构造函数 2.赋值3.数据存取 3.大小操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Maker</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;Maker *&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Maker</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Maker</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">19</span>));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">Maker</span>(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Maker *m = q.<span class="built_in">front</span>();</span><br><span class="line">		cout &lt;&lt; m-&gt;name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m-&gt;age &lt;&lt; endl;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">delete</span> m;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Set/MultiSet</title>
    <url>/2023/03/28/STL-set_multiset/</url>
    <content><![CDATA[<h1 id="Set-x2F-MultiSet"><a href="#Set-x2F-MultiSet" class="headerlink" title="Set&#x2F;MultiSet"></a>Set&#x2F;MultiSet</h1><p>set容器是关联式容器，容器自身有规则，通过键值排序，set容器中的元素是键值也是实值</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>平衡二叉树</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>双向迭代器</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>set容器和multiset容器的区别是multiset允许有相同的元素</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>构造函数</p>
<p>set<code>&lt;T&gt;</code> st;&#x2F;&#x2F;set默认构造函数：</p>
<p>mulitset<code>&lt;T&gt;</code> mst; &#x2F;&#x2F;multiset默认构造函数:</p>
<p>set(const set &amp;st);&#x2F;&#x2F;拷贝构造函数</p>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>set&amp;operator&#x3D;(const set &amp;st);&#x2F;&#x2F;重载等号操作符</p>
<p>swap(st);&#x2F;&#x2F;交换两个集合容器</p>
<h1 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h1><p>size();&#x2F;&#x2F;返回容器中元素的数目</p>
<p>empty();&#x2F;&#x2F;判断容器是否为空</p>
<h1 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h1><p>insert(elem);&#x2F;&#x2F;在容器中插入元素。</p>
<p>clear();&#x2F;&#x2F;清除所有元素</p>
<p>erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</p>
<p>erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">//自身规则默认从小到大</span></span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><pre><code>find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
</code></pre>
<ol>
<li><p>count(key);&#x2F;&#x2F;查找键key的元素个数</p>
</li>
<li><p>lower_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;&#x3D;keyElem元素的迭代器。</p>
</li>
<li><p>upper_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。</p>
<p> equal_range(keyElem);&#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>,myfunc&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    set&lt;<span class="type">int</span>,myfunc&gt;::iterator it=s.<span class="built_in">find</span>(<span class="number">90</span>);</span><br><span class="line">    <span class="keyword">if</span>(it==s.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查找失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查找成功&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找大于等于2的最小的数,注意这里的大于等于对于的是默认的升序，</span></span><br><span class="line">    <span class="comment">//那么我们定义的是降序，所以这里的lower_bound()是查找第一个小于等于2的数</span></span><br><span class="line">    it=s.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(it==s.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查找失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查找成功:&quot;</span>&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回第一个key&gt;keyElem元素的迭代器。，同理这里是&lt;</span></span><br><span class="line">    it=s.<span class="built_in">upper_bound</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(it==s.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查找失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查找成功:&quot;</span>&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">    	<span class="comment">//返回大于等于2的两个最小的数，如果有2那么就返回2和大于2的最小数</span></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span> ,myfunc&gt;::iterator,set&lt;<span class="type">int</span>,myfunc&gt;::iterator&gt; p=s.<span class="built_in">equal_range</span>(<span class="number">9</span>);</span><br><span class="line">    cout&lt;&lt;*p.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ms.<span class="built_in">count</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="改变规则（排序规则）"><a href="#改变规则（排序规则）" class="headerlink" title="改变规则（排序规则）"></a>改变规则（排序规则）</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">myfunc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1&gt;val2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不能通过算法排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>,myfunc&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自身规则进行排序，从小到大</span></span><br><span class="line">	<span class="comment">//不能通过算法排序来排序关联式容器的元素</span></span><br><span class="line">	<span class="comment">//sort(s.begin(), s.end());</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">    <span class="comment">//两种打印方式</span></span><br><span class="line">    for_each(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),print1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="储存对象"><a href="#储存对象" class="headerlink" title="储存对象"></a>储存对象</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储对象时，需要告诉set容器规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Maker</span>(string name,<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myfunc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Maker m1,Maker m2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m1.age&lt;m2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;Maker,myfunc1&gt; s;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Maker</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">1</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Maker</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Maker</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">6</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Maker</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">4</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Maker</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">8</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Maker</span>(<span class="string">&quot;hhh&quot;</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    for_each(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),[](Maker m)&#123;cout&lt;&lt;m.age&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m.name&lt;&lt;endl;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>1.set容器插入相同元素时，不会报错，但是不插入数据</p>
<p>2.set容器存储对象时，需要告诉set容器的规则</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-stack</title>
    <url>/2023/03/24/STL-stack/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的存储空间，只有一个出口，先进后出特性</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>没有迭代器</p>
<h1 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h1><p>1.构造函数 2.赋值3.数据存取 3.大小操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈容器，先进后出</span></span><br><span class="line"><span class="comment">//存储基础数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出栈中元素</span></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Maker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Maker</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存储对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;Maker&gt; s;</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="built_in">Maker</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">18</span>));</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="built_in">Maker</span>(<span class="string">&quot;bbb&quot;</span>, <span class="number">19</span>));</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="built_in">Maker</span>(<span class="string">&quot;ccc&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; s.<span class="built_in">top</span>().name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; s.<span class="built_in">top</span>().age &lt;&lt; endl;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-string</title>
    <url>/2023/03/24/STL-string/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的存储空间，用一个char*指向这片空间</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>随机访问迭代器</p>
<h1 id="常用api及其用法"><a href="#常用api及其用法" class="headerlink" title="常用api及其用法"></a>常用api及其用法</h1><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h2><p>string();&#x2F;&#x2F;创建一个空的字符串 例如: string str;<br>string(const string&amp; str);&#x2F;&#x2F;使用一个string对象初始化另一个string对象<br>string(const char* s);&#x2F;&#x2F;使用字符串s初始化<br>string(int n, char c);&#x2F;&#x2F;使用n个字符c初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;fdsjk&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">20</span>,<span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-基本赋值"><a href="#2-基本赋值" class="headerlink" title="2.基本赋值"></a>2.基本赋值</h2><p>string&amp;operator&#x3D;(const char* s);&#x2F;&#x2F;char*类型字符串 赋值给当前的字符串<br>string&amp;operator&#x3D;(const string&amp;s);&#x2F;&#x2F;把字符串s赋给当前的字符串<br>string&amp;operator&#x3D;(char c);&#x2F;&#x2F;字符赋值给当前的字符串<br>string&amp; assign(const char *s);&#x2F;&#x2F;把字符串s赋给当前的字符串<br>string&amp; assign(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串<br>string&amp; assign(const string&amp;s);&#x2F;&#x2F;把字符串s赋给当前字符串<br>string&amp; assign(int n, char c);&#x2F;&#x2F;用n个字符c赋给当前字符串<br>string&amp; assign(const string&amp;s, int start, int n);&#x2F;&#x2F;将s从start开始n个<br>字符赋值给字符串,如s&#x3D;hello,那么n&#x3D;3,start&#x3D;1，那么是hel中从e开始赋值3-1个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    string s2=s1;</span><br><span class="line">    string s3;</span><br><span class="line">    s3=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">assign</span>(<span class="string">&quot;opopop&quot;</span>);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">assign</span>(<span class="string">&quot;ioioio&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s3.<span class="built_in">assign</span>(s2,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-存取字符"><a href="#3-存取字符" class="headerlink" title="3.存取字符"></a>3.存取字符</h2><p>char&amp;operator[](int n);&#x2F;&#x2F;通过[]方式取字符<br>char&amp; at(int n);&#x2F;&#x2F;通过at方法获取字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(string::iterator it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;s.<span class="built_in">at</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//[]和at的区别：[]访问元素时，越界不抛异常，直接挂，at越界，会抛异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// cout&lt;&lt;s[1000];</span></span><br><span class="line">       s.<span class="built_in">at</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(out_of_range &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;ex.<span class="built_in">what</span>()&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;at越界&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-拼接"><a href="#4-拼接" class="headerlink" title="4.拼接"></a>4.拼接</h2><p>string&amp;operator+&#x3D;(const string&amp; str);&#x2F;&#x2F;重载+&#x3D;操作符<br>string&amp;operator+&#x3D;(const char* str);&#x2F;&#x2F;重载+&#x3D;操作符<br>string&amp;operator+&#x3D;(const char c);&#x2F;&#x2F;重载+&#x3D;操作符<br>string&amp; append(const char *s);&#x2F;&#x2F;把字符串s连接到当前字符串结尾<br>string&amp; append(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾<br>string&amp; append(const string&amp;s);&#x2F;&#x2F;同operator+&#x3D;()<br>string&amp; append(const string&amp;s, int pos, int n);&#x2F;&#x2F;把字符串s中从pos开始的n个字符连接到当前字符串结尾<br>string&amp; append(int n, char c);&#x2F;&#x2F;在当前字符串结尾添加n个字符c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;uuuuuuuuuu&quot;</span>;</span><br><span class="line">    s+=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    s.<span class="built_in">append</span>(<span class="string">&quot;iiiiiii&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    s.<span class="built_in">append</span>(<span class="string">&quot;yyyyyy&quot;</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-查找和替换"><a href="#5-查找和替换" class="headerlink" title="5.查找和替换"></a>5.查找和替换</h2><p>int find(const string&amp; str, int pos &#x3D; 0) const; &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找<br>int find(constchar* s, int pos &#x3D; 0) const;  &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找<br>int find(constchar* s, int pos, int n) const;  &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置<br>int find(constchar c, int pos &#x3D; 0) const;  &#x2F;&#x2F;查找字符c第一次出现位置<br>int rfind(conststring&amp; str, int pos &#x3D; npos) const;&#x2F;&#x2F;查找str最后一次位置,从pos开始查找<br>int rfind(constchar* s, int pos &#x3D; npos) const;&#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找<br>int rfind(constchar* s, int pos, int n) const;&#x2F;&#x2F;从pos查找s的前n个字符最后一次位置<br>int rfind(constchar c, int pos &#x3D; 0) const; &#x2F;&#x2F;查找字符c最后一次出现位置<br>string&amp; replace(int pos, int n, const string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str<br>string&amp; replace(int pos, int n, const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串s</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;abcdefghijak&quot;</span>;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">find</span>(<span class="string">&#x27;f&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">find</span>(<span class="string">&quot;cdiiiii&quot;</span>,<span class="number">0</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">rfind</span>(<span class="string">&#x27;a&#x27;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//将4个元素替换成123</span></span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-比较"><a href="#6-比较" class="headerlink" title="6.比较"></a>6.比较</h2><p>compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。<br>比较区分大小写，比较时参考字典顺序，排越前面的越小。<br>大写的A比小写的a小。</p>
<p>int compare(const string&amp;s) const;&#x2F;&#x2F;与字符串s比较<br>int compare(const char *s) const;&#x2F;&#x2F;与字符串s比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1=<span class="string">&quot;aaabc&quot;</span>;</span><br><span class="line">    string s2=<span class="string">&quot;aAabc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s1.<span class="built_in">compare</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-子串"><a href="#7-子串" class="headerlink" title="7.子串"></a>7.子串</h2><p>子串<br>string substr(int pos &#x3D; 0, int n &#x3D; npos) const;&#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;123456@xx.email&quot;</span>;</span><br><span class="line">    string s1=s.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    string s2=s.<span class="built_in">substr</span>(<span class="number">7</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-插入和删除"><a href="#8-插入和删除" class="headerlink" title="8.插入和删除"></a>8.插入和删除</h2><p>string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串<br>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串<br>string&amp; insert(int pos, int n, char c);&#x2F;&#x2F;在指定位置插入n个字符c<br>string&amp; erase(int pos, int n &#x3D; npos);&#x2F;&#x2F;删除从Pos开始的n个字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-string和const-char-转换"><a href="#9-string和const-char-转换" class="headerlink" title="9.string和const char*转换"></a>9.string和const char*转换</h2><p>string和c-style字符串转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test09</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;12345676678&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* s1=s.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">   string s2=<span class="built_in">string</span>(s1);</span><br><span class="line">   cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-用迭代器遍历字符"><a href="#10-用迭代器遍历字符" class="headerlink" title="10.用迭代器遍历字符"></a>10.用迭代器遍历字符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;9999888777&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(string::iterator it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//反向遍历  反向迭代器string::reverse_iterator</span></span><br><span class="line">    <span class="keyword">for</span>(string::reverse_iterator it=s.<span class="built_in">rbegin</span>();it!=s.<span class="built_in">rend</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">         cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="常用的api中的注意"><a href="#常用的api中的注意" class="headerlink" title="常用的api中的注意"></a>常用的api中的注意</h1><p>1.[]和at区别：[]如果越界，不抛异常，直接挂。at会抛异常</p>
<p>2.字符串内存重新分配，[]和at获取的字符引用，再次使用时，可以能会出错</p>
<p>3.string和char *的区别：string是一个类，char *是一个指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="type">char</span> &amp;a=s[<span class="number">3</span>];<span class="comment">//s[3]返回的是引用</span></span><br><span class="line">    <span class="type">char</span> &amp;b=s[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    a=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s原地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)s.<span class="built_in">c_str</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a原地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)&amp;a&lt;&lt;endl;</span><br><span class="line">    s=<span class="string">&quot;ppppppppppppppppppppppppppp&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s新地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)s.<span class="built_in">c_str</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a现地址:&quot;</span>&lt;&lt;(<span class="type">int</span>*)&amp;a&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//原空间被释放，如果还是操作a，b则是非法空间操作</span></span><br><span class="line">    a=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL-vector</title>
    <url>/2023/03/24/STL-vector/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>连续的储存空间，但在结构上是单口，无法对头部进行操作</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>随机访问迭代器</p>
<h1 id="vector容器动态增长原理"><a href="#vector容器动态增长原理" class="headerlink" title="vector容器动态增长原理"></a>vector容器动态增长原理</h1><p>1.当存储空不够时，会开辟另一块大的空间，然后把数据拷贝过去，最后在销毁原来的空间</p>
<p>2.申请的空间,会比用户需求大一点</p>
<p>3.重新分配空间，那么原来的迭代器就会失效</p>
<h1 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h1><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h2><p>vector <code>&lt;T&gt;</code> v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数</p>
<p>vector(v.begin(), v.end());&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。</p>
<p>vector(n, elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。</p>
<p>vector(const vector &amp;vec);&#x2F;&#x2F;拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(arr,arr+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">Rprint</span>(v);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-赋值操作"><a href="#2-赋值操作" class="headerlink" title="2.赋值操作"></a>2.赋值操作</h2><p>assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p>
<p>assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。</p>
<p>vector&amp;operator&#x3D;(const vector  &amp;vec);&#x2F;&#x2F;重载等号操作符</p>
<p>swap(vec);&#x2F;&#x2F; 将vec与本身的元素互换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">6</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">swap</span>(v2);<span class="comment">//最快的方式将指针交换</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-大小操作"><a href="#3-大小操作" class="headerlink" title="3.大小操作"></a>3.大小操作</h2><p>size();&#x2F;&#x2F;返回容器中元素的个数</p>
<p>empty();&#x2F;&#x2F;判断容器是否为空</p>
<p>resize(int num);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>resize(int num, elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</p>
<p>capacity();&#x2F;&#x2F;容器的容量</p>
<p>reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.resize开辟空间，并初始化</span></span><br><span class="line">	<span class="comment">//2.reserve开辟空间，但不初始化</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	v2.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">print</span>(v2);</span><br><span class="line"></span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; v2[10] &lt;&lt; endl;//err,不能访问未初始化的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-reserve的作用"><a href="#4-reserve的作用" class="headerlink" title="4.reserve的作用"></a>4.reserve的作用</h2><p>预开辟空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不写reserve，那么将多次开辟空间</span></span><br><span class="line">    <span class="comment">//v.reserve(100);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>*p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100866666</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p!=&amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p=&amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-swap的作用"><a href="#5-swap的作用" class="headerlink" title="5.swap的作用"></a>5.swap的作用</h2><p>使用匿名对象缩小capacity</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//step1.  v2用来测试</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//vecor拷贝构造，只会赋值，不会将空间复制</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step2. 将step1省略，使用匿名对象</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">//vector&lt;int&gt;(匿名对象)(v).swap(v),匿名先对象调用拷贝构造，将capacity变成10，再与v交换，使得v的capacity变小</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;capacity:&quot;</span>&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size:&quot;</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-存取操作"><a href="#6-存取操作" class="headerlink" title="6.存取操作"></a>6.存取操作</h2><p>at(int idx); &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</p>
<p>operator[];&#x2F;&#x2F;返回索引idx所指的数据，越界时，运行直接报错</p>
<p>front();&#x2F;&#x2F;返回容器中第一个数据元素</p>
<p>back();&#x2F;&#x2F;返回容器中最后一个数据元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">front</span>() = <span class="number">100</span>;</span><br><span class="line">	v.<span class="built_in">back</span>() = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-插入和删除"><a href="#7-插入和删除" class="headerlink" title="7.插入和删除"></a>7.插入和删除</h2><p>insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele.</p>
<p>push_back(ele); &#x2F;&#x2F;尾部插入元素ele</p>
<p>pop_back();&#x2F;&#x2F;删除最后一个元素</p>
<p>erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素</p>
<p>erase(const_iterator pos);&#x2F;&#x2F;删除迭代器指向的元素</p>
<p>clear();&#x2F;&#x2F;删除容器中所有元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>,<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="api的注意"><a href="#api的注意" class="headerlink" title="api的注意"></a>api的注意</h1><p>1.resize开辟空间，并初始化。reserve开辟空间，但不初始化.没有初始化的空间不能访问</p>
<p>2.reserve作用：如果容器要存储大量数据时，要先开辟空间，避免多次申请空间</p>
<p>3.swap作用:缩小容器的容量</p>
<h1 id="打印vector"><a href="#打印vector" class="headerlink" title="打印vector"></a>打印vector</h1><p> 该段代码在编译时是会报错的，原因在于iterator为依赖限定名称。在T的实际类型未确定之前，</p>
<p> 编译无法知道iterator是指代类型还是某个静态成员。消除歧义的方法很简单，显式注明iterator为类型名称，</p>
<p> 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;T&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> vector&lt;T&gt;::const_iterator it=vec.<span class="built_in">begin</span>();it!=vec.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rprint</span><span class="params">(vector&lt;T&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> vector&lt;T&gt;::reverse_iterator it=vec.<span class="built_in">rbegin</span>();it!=vec.<span class="built_in">rend</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/2023/04/02/sql-%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="第04章-运算符"><a href="#第04章-运算符" class="headerlink" title="第04章_运算符"></a>第04章_运算符</h1><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）运算。</p>
<p><img src="/img/images/image-20211012100749193.png" alt="image-20211012100749193" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>1．加法与减法运算符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">| 100 |     100 |     100 |      150 |          120 |      135.5 |       64.5 |</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由运算结果可以得出如下结论：</p>
<blockquote>
<ul>
<li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li>
<li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li>
<li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li>
<li>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</li>
</ul>
</blockquote>
<p><strong>2．乘法与除法运算符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3  | 100 DIV 0 |</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">| 100 |     100 |     100.0 |  100.0000 | 50.0000 |        105.0000 | 33.3333 |      NULL |</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#计算出员工的年基本工资</span><br><span class="line">SELECT employee_id,salary,salary * 12 annual_sal </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>由运算结果可以得出如下结论：</p>
<blockquote>
<ul>
<li>一个数乘以整数1和除以整数1后仍得原数；</li>
<li>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li>
<li>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</li>
<li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li>
<li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li>
<li>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</li>
</ul>
</blockquote>
<p><strong>3．求模（求余）运算符</strong><br>将t22表中的字段i对3和5进行求模（求余）运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 12 % 3, 12 MOD 5 FROM dual;</span><br><span class="line">+--------+----------+</span><br><span class="line">| 12 % 3 | 12 MOD 5 |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      0 |        2 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#筛选出employee_id是偶数的员工</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE employee_id MOD 2 = 0;</span><br></pre></td></tr></table></figure>

<p>可以看到，100对3求模后的结果为3，对5求模后的结果为0。</p>
<h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。</p>
<p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<p><img src="/img/images/image-20211012101110021.png" alt="image-20211012101110021" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/image-20211012104955094.png" alt="image-20211012104955094" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>1．等号运算符</strong></p>
<ul>
<li><p>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</p>
</li>
<li><p>在使用等号运算符时，遵循如下规则：</p>
<ul>
<li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li>
<li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li>
<li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li>
<li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li>
</ul>
</li>
<li><p>对比：SQL中赋值符号使用 :&#x3D;</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = 1, 1 = &#x27;1&#x27;, 1 = 0, &#x27;a&#x27; = &#x27;a&#x27;, (5 + 3) = (2 + 6), &#x27;&#x27; = NULL , NULL = NULL; </span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">| 1 = 1 | 1 = &#x27;1&#x27; | 1 = 0 | &#x27;a&#x27; = &#x27;a&#x27; | (5 + 3) = (2 + 6) | &#x27;&#x27; = NULL | NULL = NULL |</span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">|    1  |     1   |   0   |      1    |             1     |    NULL   |        NULL  |</span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = 2, 0 = &#x27;abc&#x27;, 1 = &#x27;abc&#x27; FROM dual;</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">| 1 = 2 | 0 = &#x27;abc&#x27; | 1 = &#x27;abc&#x27; |</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">|     0 |         1 |         0 |</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询salary=10000，注意在Java中比较是==</span><br><span class="line">SELECT employee_id,salary FROM employees WHERE salary = 10000;</span><br></pre></td></tr></table></figure>

<p><strong>2．安全等于运算符</strong><br>安全等于运算符（&lt;&#x3D;&gt;）与等于运算符（&#x3D;）的作用是相似的，<code>唯一的区别</code>是‘&lt;&#x3D;&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;=&gt; &#x27;1&#x27;, 1 &lt;=&gt; 0, &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27;, (5 + 3) &lt;=&gt; (2 + 6), &#x27;&#x27; &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual;</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">| 1 &lt;=&gt; &#x27;1&#x27; | 1 &lt;=&gt; 0 | &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27; | (5 + 3) &lt;=&gt; (2 + 6) | &#x27;&#x27; &lt;=&gt; NULL | NULL &lt;=&gt; NULL |</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">|         1 |       0 |           1 |                   1 |           0 |             1 |</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询commission_pct等于0.40</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;</span><br><span class="line"></span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; 0.40;</span><br><span class="line"></span><br><span class="line">#如果把0.40改成 NULL 呢？</span><br></pre></td></tr></table></figure>

<p>可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。</p>
<p><strong>3．不等于运算符</strong><br>不等于运算符（&lt;&gt;和!&#x3D;）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。<br>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, &#x27;a&#x27; != &#x27;b&#x27;, (3+4) &lt;&gt; (2+6), &#x27;a&#x27; != NULL, NULL &lt;&gt; NULL; </span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">| 1 &lt;&gt; 1 | 1 != 2 | &#x27;a&#x27; != &#x27;b&#x27; | (3+4) &lt;&gt; (2+6) | &#x27;a&#x27; != NULL | NULL &lt;&gt; NULL |</span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">|      0 |   1    |       1    |            1   |     NULL    |         NULL |</span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>此外，还有非符号类型的运算符：</p>
<p><img src="/img/images/image-20211012105303219.png" alt="image-20211012105303219" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/image-20211012105030527.png" alt="image-20211012105030527" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/image-20211012105052456.png" alt="image-20211012105052456" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> </span><br><span class="line">FROMemployees </span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span><span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> LEAST( first_name, last_name ),</span><br><span class="line">	GREATEST( first_name, last_name ),</span><br><span class="line">	salary 薪水 </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name 性,salary </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	salary <span class="keyword">BETWEEN</span> <span class="number">10000</span> </span><br><span class="line">	<span class="keyword">AND</span> <span class="number">14000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="number">1</span> <span class="operator">=</span> <span class="number">2</span>,</span><br><span class="line">	<span class="number">1</span> <span class="operator">!=</span> <span class="number">2</span>,</span><br><span class="line">	<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">	<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="number">0</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> #字符串存在隐式转换，转换不成功就是<span class="number">0</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	DUAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="string">&#x27;a&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;ab&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;ab&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;a&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;ab&#x27;</span> #两边都是字符串的话按照ASCII来比较</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	DUAL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="number">1</span> <span class="operator">=</span> <span class="keyword">NULL</span> #<span class="keyword">NULL</span>参与运算结果就是<span class="keyword">null</span>	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	DUAL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary &quot;薪水&quot; </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line">#<span class="keyword">WHERE</span> salary<span class="operator">=</span><span class="number">6000</span>;#<span class="keyword">SQL</span>里面等于是一个<span class="operator">=</span></span><br><span class="line">#<span class="keyword">WHERE</span> commission_pct<span class="operator">=</span><span class="keyword">NULL</span>;<span class="keyword">NULL</span>参与就是返回<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#<span class="operator">&lt;=&gt;</span>安全等于,用于解决有<span class="keyword">null</span>参与的情况</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary &quot;薪水&quot; </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary &quot;薪水&quot; </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">NOT</span> commission_pct <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">NULL</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="number">0</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	DUAL;</span><br><span class="line">	</span><br><span class="line">#<span class="keyword">IS</span> <span class="keyword">NULL</span> \<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> \ISNULL</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary &quot;薪水&quot; </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary &quot;薪水&quot; </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	last_name,</span><br><span class="line">	salary &quot;薪水&quot; </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	ISNULL( commission_pct );#LEAST(value1,value2,...)\GREATEST(value1,value2,...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	LEAST( <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ),</span><br><span class="line">	GREATEST( <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	DUAL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	LEAST( first_name, last_name ),</span><br><span class="line">	GREATEST(</span><br><span class="line">		LENGTH( first_name ),</span><br><span class="line">	LENGTH( last_name )) #横向比较,不是纵向</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	employees;#<span class="keyword">BETWEEN</span> <span class="keyword">AND</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	employee_id ID,</span><br><span class="line">	last_name 姓名,</span><br><span class="line">	salary 薪水 </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line">#<span class="keyword">WHERE</span> salary <span class="keyword">between</span> <span class="number">6000</span> <span class="keyword">AND</span> <span class="number">8000</span>;</span><br><span class="line">#<span class="keyword">WHERE</span> <span class="keyword">NOT</span> salary <span class="keyword">BETWEEN</span> <span class="number">6000</span> <span class="keyword">AND</span> <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">6000</span> <span class="operator">||</span> salary <span class="operator">&gt;</span> <span class="number">8000</span>;#<span class="operator">&amp;&amp;</span> <span class="operator">||</span> 都存在</span><br><span class="line">	</span><br><span class="line">#<span class="keyword">IN</span> \ <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">SELECT</span> job_id, department_id </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line">#<span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="number">30</span> )</span><br><span class="line"></span><br><span class="line">#<span class="keyword">LIKE</span> 模糊查询</span><br><span class="line">#查询lastname中包含字符a的</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">#<span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span><span class="operator">&amp;&amp;</span> last_name <span class="keyword">LIKE</span><span class="string">&#x27;%e%&#x27;</span>;# <span class="operator">%</span> 代表不确定字符个数（<span class="number">0</span>个，<span class="number">1</span>个，多个),<span class="operator">%</span>a<span class="operator">%</span>表示a前后的字符个数不确定，<span class="operator">%</span>a表示a前面字符个数不确定</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%e%&#x27;</span> <span class="keyword">OR</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%e%a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查询第二个是a的员工信息,</span><br><span class="line">#_表示<span class="number">1</span>个不确定字符</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查询第二个字符是_ 第三个字符是a的员工信息</span><br><span class="line">#使用转义字符\  转义字符后的不再是原有字符意思</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_\_a%&#x27;</span>;</span><br><span class="line">#或者(不常用)</span><br><span class="line">#<span class="keyword">ESCAPE</span> 标记某个字符为转移字符</span><br><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;_p_a%&#x27;</span> <span class="keyword">ESCAPE</span><span class="string">&#x27;p&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#REGEXP \ RLIKE 正则表达式</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;^s&#x27;</span>, <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;t$&#x27;</span>, <span class="string">&#x27;shkstart&#x27;</span> REGEXP <span class="string">&#x27;hk&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;atguigu&#x27;</span> REGEXP<span class="string">&#x27;gu.gu&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span> REGEXP <span class="string">&#x27;[ab]&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="keyword">OR</span> <span class="operator">||</span> \\<span class="keyword">AND</span> <span class="operator">&amp;&amp;</span> \\<span class="keyword">NOT</span> <span class="operator">!</span>\\XOR <span class="operator">^</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">^</span><span class="number">0</span>,<span class="number">1</span><span class="operator">&amp;&amp;</span><span class="number">1</span>,<span class="number">1</span><span class="operator">||</span><span class="number">0</span>,<span class="operator">!</span><span class="number">1</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>4. 空运算符</strong><br>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。<br>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL(&#x27;a&#x27;), 1 IS NULL;</span><br><span class="line">+--------------+--------------+-------------+-----------+</span><br><span class="line">| NULL IS NULL | ISNULL(NULL) | ISNULL(&#x27;a&#x27;) | 1 IS NULL |</span><br><span class="line">+--------------+--------------+-------------+-----------+</span><br><span class="line">|            1 |            1 |           0 |         0 |</span><br><span class="line">+--------------+--------------+-------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询commission_pct等于NULL。比较如下的四种写法</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, manager_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  manager_id IS NULL;</span><br></pre></td></tr></table></figure>

<p><strong>5. 非空运算符</strong><br>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。<br>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IS NOT NULL, &#x27;a&#x27; IS NOT NULL,  1 IS NOT NULL; </span><br><span class="line">+------------------+-----------------+---------------+</span><br><span class="line">| NULL IS NOT NULL | &#x27;a&#x27; IS NOT NULL | 1 IS NOT NULL |</span><br><span class="line">+------------------+-----------------+---------------+</span><br><span class="line">|                0 |               1 |             1 |</span><br><span class="line">+------------------+-----------------+---------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询commission_pct不等于NULL</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct &lt;=&gt; NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);</span><br></pre></td></tr></table></figure>

<p><strong>6. 最小值运算符</strong><br>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LEAST (1,0,2), LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), LEAST(1,NULL,2);</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">|       0       |        a           |      NULL       |</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<p><strong>7. 最大值运算符</strong><br>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT GREATEST(1,0,2), GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), GREATEST(1,NULL,2);</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">|               2 | c                     |               NULL |</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<p><strong>8. BETWEEN AND运算符</strong><br>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27;;</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27; |</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">|                 1 |                    0 |                       1 |</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary BETWEEN 2500 AND 3500;</span><br></pre></td></tr></table></figure>

<p><strong>9. IN运算符</strong><br>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 IN (2,3), NULL IN (&#x27;a&#x27;,&#x27;b&#x27;), &#x27;a&#x27; IN (&#x27;a&#x27;, NULL);</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">| &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 IN (2,3) | NULL IN (&#x27;a&#x27;,&#x27;b&#x27;) | &#x27;a&#x27; IN (&#x27;a&#x27;, NULL) |</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">|            1         |        0   |         NULL      |         1          |</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, salary, manager_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  manager_id IN (100, 101, 201);</span><br></pre></td></tr></table></figure>

<p><strong>10. NOT IN运算符</strong><br>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 NOT IN (2,3);</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">| &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 NOT IN (2,3) |</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">|                 0        |            1   |</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>11. LIKE运算符</strong><br>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p>
<p>LIKE运算符通常使用如下通配符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“%”：匹配0个或多个字符。</span><br><span class="line">“_”：只能匹配一个字符。</span><br></pre></td></tr></table></figure>

<p>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULL LIKE &#x27;abc&#x27;, &#x27;abc&#x27; LIKE NULL;  </span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| NULL LIKE &#x27;abc&#x27; | &#x27;abc&#x27; LIKE NULL |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">|          NULL   |          NULL   |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	first_name</span><br><span class="line">FROM 	employees</span><br><span class="line">WHERE	first_name LIKE &#x27;S%&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  last_name LIKE &#x27;_o%&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>ESCAPE</strong></p>
<ul>
<li>回避特殊符号的：<strong>使用转义符</strong>。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT job_id</span><br><span class="line">FROM   jobs</span><br><span class="line">WHERE  job_id LIKE ‘IT\_%‘;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT job_id</span><br><span class="line">FROM   jobs</span><br><span class="line">WHERE  job_id LIKE ‘IT$_%‘ escape ‘$‘;</span><br></pre></td></tr></table></figure>

<p><strong>12. REGEXP运算符</strong></p>
<p>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。</p>
<p>REGEXP运算符在进行匹配时，常用的有下面几种通配符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）‘^’匹配以该字符后面的字符开头的字符串。</span><br><span class="line">（2）‘$’匹配以该字符前面的字符结尾的字符串。</span><br><span class="line">（3）‘.’匹配任何一个单字符。</span><br><span class="line">（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class="line">（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。</span><br></pre></td></tr></table></figure>

<p>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;;</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">| &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;  |</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">|                      1 |                      1 |                       1 |</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27;, &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27;;</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">| &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27; | &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27; |</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">|                        1 |                       1 |</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。</p>
<p>MySQL中支持4种逻辑运算符如下：</p>
<p><img src="/img/images/image-20211012110241418.png" alt="image-20211012110241418" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>1．逻辑非运算符</strong><br>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;    </span><br><span class="line">+-------+-------+----------+--------+----------+</span><br><span class="line">| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |</span><br><span class="line">+-------+-------+----------+--------+----------+</span><br><span class="line">|     0 |     1 |        0 |      1 |     NULL |</span><br><span class="line">+-------+-------+----------+--------+----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  job_id NOT IN (&#x27;IT_PROG&#x27;, &#x27;ST_CLERK&#x27;, &#x27;SA_REP&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>2．逻辑与运算符</strong><br>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;</span><br><span class="line">+----------+---------+------------+------------+</span><br><span class="line">| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |</span><br><span class="line">+----------+---------+------------+------------+</span><br><span class="line">|        1 |       0 |          0 |       NULL |</span><br><span class="line">+----------+---------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary &gt;=10000</span><br><span class="line">AND    job_id LIKE &#x27;%MAN%&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>3．逻辑或运算符</strong><br>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;     </span><br><span class="line">+---------+--------+-----------+-----------+--------------+</span><br><span class="line">| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |</span><br><span class="line">+---------+--------+-----------+-----------+--------------+</span><br><span class="line">|       1 |      1 |         1 |    NULL   |       NULL   |</span><br><span class="line">+---------+--------+-----------+-----------+--------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询基本薪资不在9000-12000之间的员工编号和基本薪资</span><br><span class="line">SELECT employee_id,salary FROM employees </span><br><span class="line">WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000);</span><br><span class="line"></span><br><span class="line">SELECT employee_id,salary FROM employees </span><br><span class="line">WHERE salary &lt;9000 OR salary &gt; 12000;</span><br><span class="line"></span><br><span class="line">SELECT employee_id,salary FROM employees </span><br><span class="line">WHERE salary NOT BETWEEN 9000 AND 12000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary &gt;= 10000</span><br><span class="line">OR     job_id LIKE &#x27;%MAN%&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
</blockquote>
<p><strong>4．逻辑异或运算符</strong><br>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;</span><br><span class="line">+----------+---------+---------+------------+---------------+---------------+</span><br><span class="line">| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |</span><br><span class="line">+----------+---------+---------+------------+---------------+---------------+</span><br><span class="line">|        0 |       1 |       0 |       NULL |             1 |             0 |</span><br><span class="line">+----------+---------+---------+------------+---------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select last_name,department_id,salary </span><br><span class="line">from employees</span><br><span class="line">where department_id in (10,20) XOR salary &gt; 8000;</span><br></pre></td></tr></table></figure>

<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p>
<p>MySQL支持的位运算符如下：</p>
<p><img src="/img/images/image-20211012110511223.png" alt="image-20211012110511223" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>1．按位与运算符</strong><br>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &amp; 10, 20 &amp; 30;</span><br><span class="line">+--------+---------+</span><br><span class="line">| 1 &amp; 10 | 20 &amp; 30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">|      0 |      20 |</span><br><span class="line">+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0001，10的二进制数为1010，所以1 &amp; 10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20 &amp; 30的结果为10100，对应的十进制数为20。</p>
<p><strong>2. 按位或运算符</strong><br>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 | 10, 20 | 30; </span><br><span class="line">+--------+---------+</span><br><span class="line">| 1 | 10 | 20 | 30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">|     11 |      30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。</p>
<p><strong>3. 按位异或运算符</strong><br>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 ^ 10, 20 ^ 30; </span><br><span class="line">+--------+---------+</span><br><span class="line">| 1 ^ 10 | 20 ^ 30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">|     11 |      10 |</span><br><span class="line">+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。</p>
<p>再举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 12 &amp; 5, 12 | 5,12 ^ 5 FROM DUAL;</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">| 12 &amp; 5 | 12 | 5 | 12 ^ 5 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">|      4 |     13 |      9 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img src="/img/images/image-20211023115738415.png" alt="image-20211023115738415" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>4. 按位取反运算符</strong><br>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 10 &amp; ~1;</span><br><span class="line">+---------+</span><br><span class="line">| 10 &amp; ~1 |</span><br><span class="line">+---------+</span><br><span class="line">|      10 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以10 &amp; ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。</p>
<p><strong>5. 按位右移运算符</strong><br>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &gt;&gt; 2, 4 &gt;&gt; 2;</span><br><span class="line">+--------+--------+</span><br><span class="line">| 1 &gt;&gt; 2 | 4 &gt;&gt; 2 |</span><br><span class="line">+--------+--------+</span><br><span class="line">|      0 |      1 |</span><br><span class="line">+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。</p>
<p><strong>6. 按位左移运算符</strong><br>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;&lt; 2, 4 &lt;&lt; 2;  </span><br><span class="line">+--------+--------+</span><br><span class="line">| 1 &lt;&lt; 2 | 4 &lt;&lt; 2 |</span><br><span class="line">+--------+--------+</span><br><span class="line">|      4 |     16 |</span><br><span class="line">+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。</p>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p><img src="/img/images/image-20211012111042395.png" alt="image-20211012111042395" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/image-20211012110731059.png" alt="image-20211012110731059" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p>
<h1 id="拓展：使用正则表达式查询"><a href="#拓展：使用正则表达式查询" class="headerlink" title="拓展：使用正则表达式查询"></a>拓展：使用正则表达式查询</h1><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。</p>
<p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。</p>
<p><img src="/img/images/image-20210926151249943.png" alt="image-20210926151249943" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>1. 查询以特定字符或字符串开头的记录</strong><br>字符‘^’匹配以特定字符或者字符串开头的文本。</p>
<p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 查询以特定字符或字符串结尾的记录</strong><br>字符‘$’匹配以特定字符或者字符串结尾的文本。</p>
<p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>3. 用符号”.”来替代字符串中的任意一个字符</strong><br>字符‘.’匹配任意一个字符。<br>在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用”*”和”+”来匹配多个字符</strong><br>星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。</p>
<p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba*&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>5. 匹配指定字符串</strong><br>正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。</p>
<p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;</span><br></pre></td></tr></table></figure>

<p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p>
<p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name like &#x27;on&#x27;;</span><br><span class="line">Empty set(0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>6. 匹配指定字符中的任意一个</strong><br>方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。</p>
<p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#x27;[456]&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>7. 匹配指定字符以外的字符</strong><br><code>“[^字符集合]”</code>匹配不在指定集合中的任何字符。</p>
<p>在fruits表中，查询f_id字段中包含字母a<del>e和数字1</del>2以外字符的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>8. 使用{n,}或者{n,m}来指定字符串连续出现的次数</strong><br>“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。</p>
<p>在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;ba&#123;1,3&#125;&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>基本的SELECT语句</title>
    <url>/2023/04/01/sql-%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84SELECT%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="第03章-基本的SELECT语句"><a href="#第03章-基本的SELECT语句" class="headerlink" title="第03章_基本的SELECT语句"></a>第03章_基本的SELECT语句</h1><h1 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h1><h2 id="SQL背景知识"><a href="#SQL背景知识" class="headerlink" title="SQL背景知识"></a>SQL背景知识</h2><ul>
<li><p>1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。</p>
<ul>
<li>45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，<code>SQL 的半衰期可以说是非常长</code>了。</li>
</ul>
</li>
<li><p>不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。</p>
</li>
<li><p>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，<code>与数据直接打交道</code>，由<code>IBM</code>上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有<code>SQL-86</code>，<code>SQL-89</code>，<code>SQL-92</code>，<code>SQL-99</code>等标准。</p>
<ul>
<li>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。</li>
</ul>
</li>
<li><p>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</p>
</li>
</ul>
<p><a href="https://cloudimge.com/image/ovBrU"><img src="https://c.1ovv.com/2023/04/01/ovBrU.md.png" alt="ovBrU.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<h2 id="SQL语言排行榜"><a href="#SQL语言排行榜" class="headerlink" title="SQL语言排行榜"></a>SQL语言排行榜</h2><p>自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。</p>
<p><a href="https://cloudimge.com/image/ovJRw"><img src="https://c.1ovv.com/2023/04/01/ovJRw.md.png" alt="ovJRw.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<h2 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h2><p>SQL语言在功能上主要分为如下3大类：</p>
<ul>
<li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p>
<ul>
<li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li>
</ul>
</li>
<li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p>
<ul>
<li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li>
<li><strong>SELECT是SQL语言的基础，最为重要。</strong></li>
</ul>
</li>
<li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p>
<ul>
<li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。</p>
<p>还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p>
</blockquote>
<h1 id="SQL语言的规则与规范"><a href="#SQL语言的规则与规范" class="headerlink" title="SQL语言的规则与规范"></a>SQL语言的规则与规范</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>每条命令以 ; 或 \g 或 \G 结束</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号<ul>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li>
<li>列的别名，尽量使用双引号（” “），而且不建议省略as</li>
</ul>
</li>
</ul>
<h2 id="SQL大小写规范-（建议遵守）"><a href="#SQL大小写规范-（建议遵守）" class="headerlink" title="SQL大小写规范 （建议遵守）"></a>SQL大小写规范 （建议遵守）</h2><ul>
<li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li>
<li><strong>MySQL 在 Linux 环境下是大小写敏感的</strong><ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li><strong>推荐采用统一的书写规范：</strong><ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写</li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
<h2 id="注-释"><a href="#注-释" class="headerlink" title="注 释"></a>注 释</h2><p>可以使用如下格式的注释结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：-- 注释文字(--后面必须包含一个空格。)</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure>

<h2 id="命名规则（暂时了解）"><a href="#命名规则（暂时了解）" class="headerlink" title="命名规则（暂时了解）"></a>命名规则（暂时了解）</h2><ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#以下两句是一样的，不区分大小写</span><br><span class="line">show databases;</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">#创建表格</span><br><span class="line">#create table student info(...); #表名错误，因为表名有空格</span><br><span class="line">create table student_info(...); </span><br><span class="line"></span><br><span class="line">#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了</span><br><span class="line">CREATE TABLE `order`(</span><br><span class="line">    id INT,</span><br><span class="line">    lname VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">select id as &quot;编号&quot;, `name` as &quot;姓名&quot; from t_stu; #起别名时，as都可以省略</span><br><span class="line">select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略&quot;&quot;</span><br><span class="line">select id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略&quot;&quot;</span><br></pre></td></tr></table></figure>



<h2 id="数据导入指令"><a href="#数据导入指令" class="headerlink" title="数据导入指令"></a>数据导入指令</h2><p>在命令行客户端登录mysql，使用source指令导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; source d:\mysqldb.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employees;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| employee_id    | int(6)      | NO   | PRI | 0       |       |</span><br><span class="line">| first_name     | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| last_name      | varchar(25) | NO   |     | NULL    |       |</span><br><span class="line">| email          | varchar(25) | NO   | UNI | NULL    |       |</span><br><span class="line">| phone_number   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| hire_date      | date        | NO   |     | NULL    |       |</span><br><span class="line">| job_id         | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| salary         | double(8,2) | YES  |     | NULL    |       |</span><br><span class="line">| commission_pct | double(2,2) | YES  |     | NULL    |       |</span><br><span class="line">| manager_id     | int(6)      | YES  | MUL | NULL    |       |</span><br><span class="line">| department_id  | int(4)      | YES  | MUL | NULL    |       |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="基本的SELECT语句"><a href="#基本的SELECT语句" class="headerlink" title="基本的SELECT语句"></a>基本的SELECT语句</h1><h2 id="SELECT…"><a href="#SELECT…" class="headerlink" title="SELECT…"></a>SELECT…</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 1; #没有任何子句</span><br><span class="line">SELECT 9/2; #没有任何子句</span><br></pre></td></tr></table></figure>

<h2 id="SELECT-…-FROM"><a href="#SELECT-…-FROM" class="headerlink" title="SELECT … FROM"></a>SELECT … FROM</h2><ul>
<li>语法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   标识选择哪些列</span><br><span class="line"><span class="keyword">FROM</span>     标识从哪个表中选择</span><br></pre></td></tr></table></figure>

<ul>
<li>选择全部列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>   departments;</span><br></pre></td></tr></table></figure>

<p><a href="https://cloudimge.com/image/ovc4Z"><img src="https://c.1ovv.com/2023/04/01/ovc4Z.md.png" alt="ovc4Z.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<blockquote>
<p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p>
<p>在生产环境下，不推荐你直接使用<code>SELECT *</code>进行查询。</p>
</blockquote>
<ul>
<li>选择特定的列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, location_id</span><br><span class="line"><span class="keyword">FROM</span>   departments;</span><br></pre></td></tr></table></figure>

<p><a href="https://cloudimge.com/image/ovEKJ"><img src="https://c.1ovv.com/2023/04/01/ovEKJ.md.png" alt="ovEKJ.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<blockquote>
<p>MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。</p>
</blockquote>
<h2 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h2><ul>
<li><p>重命名一个列</p>
</li>
<li><p>便于计算</p>
</li>
<li><p>紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号</strong>，以便在别名中包含空格或特殊的字符并区分大小写。</p>
</li>
<li><p>AS 可以省略（alias）</p>
</li>
<li><p>建议别名简短，见名知意</p>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name AS name, commission_pct comm</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure>

<p><a href="https://cloudimge.com/image/ovUj1"><img src="https://c.1ovv.com/2023/04/01/ovUj1.md.png" alt="ovUj1.md.png" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></a></p>
<p><img src="/img/images/1554951622467.png" alt="1554951622467" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;#别名有空格用双引号</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/img/images/1554951648377.png" alt="1554951648377" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554951655368.png" alt="1554951655368" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h2><p>默认情况下，查询会返回全部行，包括重复行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<p><img src="/img/images/1554951711115.png" alt="1554951711115" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554951715923.png" alt="1554951715923" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<p><img src="/img/images/1554951796570.png" alt="1554951796570" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554951801044.png" alt="1554951801044" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>针对于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id,salary </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>这里有两点需要注意：</p>
<ol>
<li>DISTINCT 需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</li>
<li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</li>
</ol>
<h2 id="空值参与运算"><a href="#空值参与运算" class="headerlink" title="空值参与运算"></a>空值参与运算</h2><ul>
<li>所有运算符或列值遇到null值，运算的结果都为null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary,commission_pct,</span><br><span class="line"><span class="number">12</span> <span class="operator">*</span> salary <span class="operator">*</span> (<span class="number">1</span> <span class="operator">+</span> commission_pct) &quot;annual_sal&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>这里你一定要注意，在 MySQL 里面， 空值不等于空字符串，也不等同于0。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h2 id="着重号"><a href="#着重号" class="headerlink" title="着重号"></a>着重号</h2><ul>
<li>错误的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ORDER;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;ORDER&#x27; at line 1</span><br></pre></td></tr></table></figure>

<ul>
<li>正确的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM `ORDER`;</span><br><span class="line">+----------+------------+</span><br><span class="line">| order_id | order_name |</span><br><span class="line">+----------+------------+</span><br><span class="line">|        1 | shkstart   |</span><br><span class="line">|        2 | tomcat     |</span><br><span class="line">|        3 | dubbo      |</span><br><span class="line">+----------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM `order`;</span><br><span class="line">+----------+------------+</span><br><span class="line">| order_id | order_name |</span><br><span class="line">+----------+------------+</span><br><span class="line">|        1 | shkstart   |</span><br><span class="line">|        2 | tomcat     |</span><br><span class="line">|        3 | dubbo      |</span><br><span class="line">+----------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>结论</li>
</ul>
<p>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对&#96;&#96;（着重号）引起来。</p>
<h2 id="查询常数"><a href="#查询常数" class="headerlink" title="查询常数"></a>查询常数</h2><p>SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p>
<p>你可能会问为什么我们还要对常数进行查询呢？</p>
<p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
<p>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段<code>corporation</code>，这个字段固定值为“尚硅谷”，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;尚硅谷&#x27; as corporation, last_name FROM employees;</span><br></pre></td></tr></table></figure>



<h1 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h1><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE employees;</span><br><span class="line">或</span><br><span class="line">DESC employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employees;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| employee_id    | int(6)      | NO   | PRI | 0       |       |</span><br><span class="line">| first_name     | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| last_name      | varchar(25) | NO   |     | NULL    |       |</span><br><span class="line">| email          | varchar(25) | NO   | UNI | NULL    |       |</span><br><span class="line">| phone_number   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| hire_date      | date        | NO   |     | NULL    |       |</span><br><span class="line">| job_id         | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| salary         | double(8,2) | YES  |     | NULL    |       |</span><br><span class="line">| commission_pct | double(2,2) | YES  |     | NULL    |       |</span><br><span class="line">| manager_id     | int(6)      | YES  | MUL | NULL    |       |</span><br><span class="line">| department_id  | int(4)      | YES  | MUL | NULL    |       |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>其中，各个字段的含义分别解释如下：</p>
<ul>
<li>Field：表示字段名称。 </li>
<li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li>
<li>Null：表示该列是否可以存储NULL值。</li>
<li>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。</li>
<li>Default：表示该列是否有默认值，如果有，那么值是多少。</li>
<li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li>
</ul>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><ul>
<li>背景：</li>
</ul>
<p><img src="/img/images/1554952199742.png" alt="1554952199742" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1,字段2</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 过滤条件</span><br></pre></td></tr></table></figure>

<ul>
<li>使用WHERE 子句，将不满足条件的行过滤掉</li>
<li><strong>WHERE子句紧随 FROM子句</strong></li>
</ul>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">90</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="/img/images/1554952277028.png" alt="1554952277028" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>排序与分页</title>
    <url>/2023/04/02/sql-%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="第05章-排序与分页"><a href="#第05章-排序与分页" class="headerlink" title="第05章_排序与分页"></a>第05章_排序与分页</h1><hr>
<h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1.1 排序规则"></a>1.1 排序规则</h3><ul>
<li>使用 ORDER BY 子句排序<ul>
<li><strong>ASC（ascend）: 升序</strong></li>
<li><strong>DESC（descend）:降序</strong></li>
</ul>
</li>
<li><strong>ORDER BY 子句在SELECT语句的结尾。</strong></li>
</ul>
<h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1.2 单列排序"></a>1.2 单列排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT   last_name, job_id, department_id, hire_date</span><br><span class="line">FROM     employees</span><br><span class="line">ORDER BY hire_date ;</span><br></pre></td></tr></table></figure>

<p> <img src="/img/images/1554974255957.png" alt="1554974255957" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554974260133.png" alt="1554974260133" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT   last_name, job_id, department_id, hire_date</span><br><span class="line">FROM     employees</span><br><span class="line">ORDER BY hire_date DESC ;</span><br></pre></td></tr></table></figure>

<p> <img src="/img/images/1554974822229.png" alt="1554974822229" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554974827522.png" alt="1554974827522" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, salary*12 annsal</span><br><span class="line">FROM   employees</span><br><span class="line">ORDER BY annsal;</span><br></pre></td></tr></table></figure>

<p> <img src="/img/images/1554974853194.png" alt="1554974853194" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554974858252.png" alt="1554974858252" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1.3 多列排序"></a>1.3 多列排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, department_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">ORDER BY department_id, salary DESC;</span><br></pre></td></tr></table></figure>

<p><img src="/img/images/1554974901572.png" alt="1554974901572" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/img/images/1554974907498.png" alt="1554974907498" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>可以使用不在SELECT列表中的列排序。</li>
<li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li>
</ul>
<h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><h3 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1 背景"></a>2.1 背景</h3><p>背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？</p>
<p>背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？</p>
<h3 id="2-2-实现规则"><a href="#2-2-实现规则" class="headerlink" title="2.2 实现规则"></a>2.2 实现规则</h3><ul>
<li><p>分页原理</p>
<p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。</p>
</li>
<li><p><strong>MySQL中使用 LIMIT 实现分页</strong></p>
</li>
<li><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT [位置偏移量,] 行数</span><br></pre></td></tr></table></figure>

<p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</p>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--前10条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 0,10;</span><br><span class="line">或者</span><br><span class="line">SELECT * FROM 表名 LIMIT 10;</span><br><span class="line"></span><br><span class="line">--第11至20条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 10,10;</span><br><span class="line"></span><br><span class="line">--第21至30条记录： </span><br><span class="line">SELECT * FROM 表名 LIMIT 20,10;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p>
</blockquote>
<ul>
<li>分页显式公式<strong>：（当前页数-1）*每页条数，每页条数</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table </span><br><span class="line">LIMIT(PageNo - 1)*PageSize,PageSize;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：LIMIT 子句必须放在整个SELECT语句的最后！</strong></li>
<li>使用 LIMIT 的好处</li>
</ul>
<p>约束返回结果的数量可以<code>减少数据表的网络传输量</code>，也可以<code>提升查询效率</code>。如果我们知道返回结果只有 1 条，就可以使用<code>LIMIT 1</code>，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#排序</span><br><span class="line">#默认为查询返回数据是按照当初添加数据顺序</span><br><span class="line">#一级排序，单列排序</span><br><span class="line"></span><br><span class="line">#按照salary从高到低排序</span><br><span class="line">#<span class="keyword">ORDER</span> <span class="keyword">BY</span>进行排序</span><br><span class="line"># <span class="keyword">ASC</span>(ascend)升序</span><br><span class="line"># <span class="keyword">DESC</span>（descend)降序</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">#<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br><span class="line">#<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary;</span><br><span class="line"></span><br><span class="line">#使用别名进行排序</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary<span class="operator">*</span><span class="number">12</span> annual_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> annual_sal;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WHERE不能使用别名                     语句执行顺序:</span></span><br><span class="line"><span class="comment">SELECT last_name,salary*12 annual_sal         3</span></span><br><span class="line"><span class="comment">FROM employees                                1</span></span><br><span class="line"><span class="comment">WHERE annual_sal&gt;60000;err                    2   别名在where后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">WHERE</span>在<span class="keyword">from</span>后<span class="keyword">order</span>前</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">50</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#二级排序(多级排序)</span><br><span class="line">#department_id降序，id相同的salary升序</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-拓展"><a href="#2-3-拓展" class="headerlink" title="2.3 拓展"></a>2.3 拓展</h3><p>在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。</p>
<ul>
<li>如果是 SQL Server 和 Access，需要使用 <code>TOP</code> 关键字，比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 DB2，使用<code>FETCH FIRST 5 ROWS ONLY</code>这样的关键字：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 Oracle，你需要基于 <code>ROWNUM</code> 来统计行数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT rownum, last_name,salary</span><br><span class="line">FROM (</span><br><span class="line">    SELECT last_name,salary</span><br><span class="line">    FROM employees</span><br><span class="line">    ORDER BY salary DESC)</span><br><span class="line">WHERE rownum &lt; 10;</span><br></pre></td></tr></table></figure>

<p>得到与上述方法一致的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#分页</span><br><span class="line">#LIMIT</span><br><span class="line">#每页显示<span class="number">20</span>条记录</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees  </span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">20</span>;#第一个为偏移量，第一个<span class="operator">+</span>偏移量  开始</span><br><span class="line">#显示第二页的数据</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">20</span>,<span class="number">20</span>;</span><br><span class="line">#第三页</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">40</span>,<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">#每页显示n条，此时第x页</span><br><span class="line"><span class="comment">/*SELECT employee_id,last_name</span></span><br><span class="line"><span class="comment">FROM employees</span></span><br><span class="line"><span class="comment">LIMIT (x-1)*n,n;*/</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary<span class="operator">&gt;</span><span class="number">6000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">10</span>;#最后写limit</span><br><span class="line"></span><br><span class="line">#<span class="number">8.0</span>新特性</span><br><span class="line">#LIMIT ... OFFSET...</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">LIMIT <span class="number">20</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;#ofset后为偏移量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
